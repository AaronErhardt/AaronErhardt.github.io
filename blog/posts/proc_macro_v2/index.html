<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Does Rust need proc-macros 2.0? | Eberhardt blog</title><meta name=keywords content><meta name=description content="Without any doubt, macros are an important feature of the Rust programming language. Macros like println!, lazy_static!, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.
However, not everything is perfect yet. You might have heard about the declarative macros 2.0 effort to fix some longstanding issues with macro_rules!. The new macro syntax is still WIP, but I hope it will be stabilized soon.
However, that just improves declarative macros, but Rust also has proc-macros (procedural macros)."><meta name=author content="Aaron Erhardt"><link rel=canonical href=https://aaronerhardt.github.io/blog/posts/proc_macro_v2/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://aaronerhardt.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aaronerhardt.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aaronerhardt.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://aaronerhardt.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://aaronerhardt.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Does Rust need proc-macros 2.0?"><meta property="og:description" content="Without any doubt, macros are an important feature of the Rust programming language. Macros like println!, lazy_static!, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.
However, not everything is perfect yet. You might have heard about the declarative macros 2.0 effort to fix some longstanding issues with macro_rules!. The new macro syntax is still WIP, but I hope it will be stabilized soon.
However, that just improves declarative macros, but Rust also has proc-macros (procedural macros)."><meta property="og:type" content="article"><meta property="og:url" content="https://aaronerhardt.github.io/blog/posts/proc_macro_v2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Does Rust need proc-macros 2.0?"><meta name=twitter:description content="Without any doubt, macros are an important feature of the Rust programming language. Macros like println!, lazy_static!, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.
However, not everything is perfect yet. You might have heard about the declarative macros 2.0 effort to fix some longstanding issues with macro_rules!. The new macro syntax is still WIP, but I hope it will be stabilized soon.
However, that just improves declarative macros, but Rust also has proc-macros (procedural macros)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aaronerhardt.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Does Rust need proc-macros 2.0?","item":"https://aaronerhardt.github.io/blog/posts/proc_macro_v2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Does Rust need proc-macros 2.0?","name":"Does Rust need proc-macros 2.0?","description":"Without any doubt, macros are an important feature of the Rust programming language. Macros like println!, lazy_static!, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.\nHowever, not everything is perfect yet. You might have heard about the declarative macros 2.0 effort to fix some longstanding issues with macro_rules!. The new macro syntax is still WIP, but I hope it will be stabilized soon.\nHowever, that just improves declarative macros, but Rust also has proc-macros (procedural macros).","keywords":[],"articleBody":"Without any doubt, macros are an important feature of the Rust programming language. Macros like println!, lazy_static!, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.\nHowever, not everything is perfect yet. You might have heard about the declarative macros 2.0 effort to fix some longstanding issues with macro_rules!. The new macro syntax is still WIP, but I hope it will be stabilized soon.\nHowever, that just improves declarative macros, but Rust also has proc-macros (procedural macros).\nProc-macros are awesome I‚Äôm not going to explain proc-macros in this article, but you can find more information here.\nFirst, let‚Äôs look at what makes proc-macros such a valuable feature for Rust. Proc-macros are essentially extensions for the compiler that turn token streams into token streams. In between, you can use regular Rust code and arbitrarily complex logic to reorder, create, remove or transform tokens. There are hardly any limitations. This makes proc-macros incredibly powerful and useful in situations declarative macros can‚Äôt handle.\nThe problems Proc-macros are powerful, but they are also very difficult to implement correctly. It‚Äôs up to the individual developer to parse the macro syntax and to handle every edge-case. At the same time, language servers struggle a lot to provide decent IDE integration for proc-macros because they have no idea how the macro works internally.\nLet‚Äôs have a closer look at some of those problems.\nA black box The following code is an example of an imaginary #[async_runtime::main] attribute macro:\n#[async_runtime::main] async fn main() { log::info!(\"Starting application! üöÄüöÄüöÄ\"); start_server().await; } Obviously, the #[async_runtime::main] macro just creates some boilerplate to start an async function, right? Actually, we don‚Äôt know and neither does the compiler until it calls the proc-macro. Unless you analyze the shared library or the source code of the proc-macro, you‚Äôll never know what code will be generated until you try it out. And even then, you don‚Äôt know whether the code generation will completely change as soon as you type another letter.\nIn our example, this could have been a valid expansion of the macro:\nfn main() { open_link(\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"); } To be fair, macros tend to produce rather predictable code in order to be usable. Yet, language servers suffer a lot more from this problem.\nFor now, language server try to solve this problem by guessing that if something looks familiar, the macro probably does nothing unexpected. Only if the output looks similar to the input and to a known Rust pattern, language servers enable auto-completion and other cool features. However, this is still fragile because you never know what‚Äôs happening inside of the macro. More importantly though, language servers will probably never do anything more than error reporting for proc-macros that look only slightly different from valid Rust code.\nSandboxing I‚Äôm sure that by now many Rust programmers are aware that proc-macros can execute arbitrary code. Yet, there‚Äôs still no sandboxing by default. Ideally, Rust would sandbox proc-macros and also the execution of the binary which could contain malicious macro-generated code too. For example, proc-macros shouldn‚Äôt be able to access the file system or the internet by default. In reality, this is easier said than done, but in my opinion, it‚Äôs only a matter of time until the lack of sandboxing will be exploited.\nHygiene Proc-macros are unhygienic, which means that they are affected by the context they are called from. To avoid naming conflicts, it‚Äôs recommended to use absolute paths for imports (e.g. ::std::thread::spawn). This works great as long as the required crates can be imported with absolute paths. However, once another crate re-exports a required crate, a user would usually just import the top-level crate and use its re-export. Yet, this changes the absolute path of the crate, which in turn breaks the macro.\nIdeally, Rust should be able to recognize paths that are independent from external items and should be evaluated in the context of ‚Äúmacro dependencies‚Äù. That wouldn‚Äôt make macros entirely hygienic but certainly less error-prone.\nProc-macro 2.0? The compiler team has been aware of issues regarding sandboxing and macro hygiene for a long time now and I hope they will be addressed soon. However, IDE integration and complex code parsing have been two longstanding issues that were only addressed partially.\nI think it‚Äôs time to solve these issues properly.\nA declarative parsing description The syn crate and more recently venial try to improve macro parsing by defining some structures and functionality to parse them. Both crates have shown that it is possible to represent macro syntax with Rust‚Äôs data structures. However, the compiler still doesn‚Äôt understand what‚Äôs going on internally and custom syntax needs manual parsing logic.\nRust‚Äôs syntax is documented in the Rust reference with its own notation. This implies that it is possible to specify Rust‚Äôs syntax and probably also the syntax of most macros in a simple format.\nCombining both ideas has huge potential: A simple notation that can be represented by Rust‚Äôs data structures and read by machines as syntax description would solve both problems. This notation could be its own lightweight language or just Rust data structures.\nFor examples, the compiler could expose some basic parsable types (e.g. structs or trait impls) and derive parsing definitions for custom types. If all types used by the macro have to let the compiler derive their parsing logic, it would be easy for language servers and the compiler itself to understand the syntax of the macro. All you need to do then is to tell the Rust compiler where to start parsing and it will return the Rust types corresponding to your syntax description.\nRust reference grammar description Derived parsing definition StructField : OuterAttribute* Visibility? IDENTIFIER : Type // Not just for parsing, also defines a // syntax description. #[derive(Parse)] struct StructField { outer_attr: Vec\u003cOuterAttribute\u003e, vis: Option\u003cVisibility\u003e, ident: Identifier, _colon: Colon, ty: Type } Example for describing the syntax of a struct field\nThe biggest advantage of this approach is that it allows language servers to understand the syntax. For example, they would know that the macro is looking for code that‚Äôs a subset of Rust‚Äôs struct definition. This gives them much more opportunities to improve IDE integration.\nOpaque tokens Another improvement for IDE integration would be a concept I call ‚Äúopaque tokens‚Äù. When a macro doesn‚Äôt need to access the value of a token because it doesn‚Äôt influence the code generation, it could just as well tell the compiler that this token should be opaque. Opaque tokens would be impossible to access or modify. This gives language servers the information that a certain token is left unchanged to optimize performance while the user is typing and potentially enable even better IDE integration.\nConclusion Proc-macros are great as they are, but they have so much more potential. Rust‚Äôs third pillar - productivity - will surely profit from easier proc-macros and better IDE integration.\nI hope this article brings up more ideas and discussions to improve the status quo of proc-macros. Regardless of which solution will be chosen in the end, I believe that proc-macros deserve an upgrade.\nAppendix: A larger code example Format description\nCustomStructStruct : struct IDENTIFIER GenericParams? WhereClause? ( { StructFields? } | ; ) CustomStructFields : CustomStructField (, CustomStructField)* ,? CustomStructField : OuterAttribute* CustomVisibility? IDENTIFIER : Type CustomVisibility : pub | pub ( crate ) Rust code mockup\n// Import existing types from the compiler use proc_macro::*; #[derive(Parse)] #[subset_of(Struct)] struct CustomStruct { struct_: Struct, name: Identifier, generics: Option\u003cGenericParams\u003e, where_clause: Option\u003cWhereClause\u003e, inner: Either\u003cSemiColon, Backets\u003cOption\u003cCustomStructFields\u003e\u003e\u003e, } #[derive(Parse)] #[subset_of(StructFields)] struct CustomStructFields { // We don't want to touch the struct field // so we wrap it into `Opaque`. fields: Punctuated\u003cOpaque\u003cCustomStructField\u003e\u003e, } #[derive(Parse)] #[subset_of(StructField)] struct CustomStructField { outer_attr: Vec\u003cOuterAttribute\u003e, vis: Option\u003cCustomVisibility\u003e, ident: Identifier, _colon: Colon, ty: Type } #[derive(Parse)] #[subset_of(Visibility)] enum CustomVisibility { Pub(Pub), PubCrate((Pub, Crate)), } ","wordCount":"1292","inLanguage":"en","datePublished":"2022-07-27T00:00:00Z","dateModified":"2022-07-27T00:00:00Z","author":{"@type":"Person","name":"Aaron Erhardt"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronerhardt.github.io/blog/posts/proc_macro_v2/"},"publisher":{"@type":"Organization","name":"Eberhardt blog","logo":{"@type":"ImageObject","url":"https://aaronerhardt.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aaronerhardt.github.io/blog/ accesskey=h title="Eberhardt blog (Alt + H)">Eberhardt blog</a><div class=logo-switches></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aaronerhardt.github.io/blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://aaronerhardt.github.io/blog/posts/>Posts</a></div><h1 class=post-title>Does Rust need proc-macros 2.0?</h1><div class=post-meta><span title='2022-07-27 00:00:00 +0000 UTC'>July 27, 2022</span>&nbsp;¬∑&nbsp;7 min&nbsp;¬∑&nbsp;Aaron Erhardt&nbsp;|&nbsp;<a href=https://github.com/AaronErhardt/AaronErhardt.github.io/tree/blog/content/posts/proc_macro_v2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Without any doubt, macros are an important feature of the Rust programming language.
Macros like <code>println!</code>, <code>lazy_static!</code>, various derive-macros and many others have saved countless hours of writing tedious boilerplate code.</p><p>However, not everything is perfect yet.
You might have heard about the <a href=https://github.com/rust-lang/rust/issues/39412>declarative macros 2.0</a> effort to fix some longstanding issues with <code>macro_rules!</code>.
The new macro syntax is still WIP, but I hope it will be stabilized soon.</p><p>However, that just improves declarative macros, but Rust also has proc-macros (procedural macros).</p><h2 id=proc-macros-are-awesome>Proc-macros are awesome<a hidden class=anchor aria-hidden=true href=#proc-macros-are-awesome>#</a></h2><blockquote><p>I&rsquo;m not going to explain proc-macros in this article, but you can find more information <a href=https://doc.rust-lang.org/reference/procedural-macros.html>here</a>.</p></blockquote><p>First, let&rsquo;s look at what makes proc-macros such a valuable feature for Rust.
Proc-macros are essentially extensions for the compiler that turn token streams into token streams.
In between, you can use regular Rust code and arbitrarily complex logic to reorder, create, remove or transform tokens.
There are hardly any limitations.
This makes proc-macros incredibly powerful and useful in situations declarative macros can&rsquo;t handle.</p><h2 id=the-problems>The problems<a hidden class=anchor aria-hidden=true href=#the-problems>#</a></h2><p>Proc-macros are powerful, but they are also very difficult to implement correctly.
It&rsquo;s up to the individual developer to parse the macro syntax and to handle every edge-case.
At the same time, language servers struggle a lot to provide decent IDE integration for proc-macros because they have no idea how the macro works internally.</p><p>Let&rsquo;s have a closer look at some of those problems.</p><h3 id=a-black-box>A black box<a hidden class=anchor aria-hidden=true href=#a-black-box>#</a></h3><p>The following code is an example of an imaginary <code>#[async_runtime::main]</code> attribute macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[async_runtime::main]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    log::info<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Starting application! üöÄüöÄüöÄ&#34;</span>);
</span></span><span style=display:flex><span>    start_server().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Obviously, the <code>#[async_runtime::main]</code> macro just creates some boilerplate to start an async function, right?
Actually, we don&rsquo;t know and neither does the compiler until it calls the proc-macro.
Unless you analyze the shared library or the source code of the proc-macro, you&rsquo;ll never know what code will be generated until you try it out.
And even then, you don&rsquo;t know whether the code generation will completely change as soon as you type another letter.</p><p>In our example, this could have been a valid expansion of the macro:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    open_link(<span style=color:#e6db74>&#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To be fair, macros tend to produce rather predictable code in order to be usable.
Yet, language servers suffer a lot more from this problem.</p><p>For now, language server try to solve this problem by guessing that if something looks familiar, the macro probably does nothing unexpected.
Only if the output looks similar to the input and to a known Rust pattern, language servers enable auto-completion and other cool features.
However, this is still fragile because you never know what&rsquo;s happening inside of the macro.
More importantly though, language servers will probably never do anything more than error reporting for proc-macros that look only slightly different from valid Rust code.</p><h3 id=sandboxing>Sandboxing<a hidden class=anchor aria-hidden=true href=#sandboxing>#</a></h3><p>I&rsquo;m sure that by now many Rust programmers are aware that proc-macros can execute arbitrary code.
Yet, there&rsquo;s still no sandboxing by default.
Ideally, Rust would sandbox proc-macros and also the execution of the binary which could contain malicious macro-generated code too.
For example, proc-macros shouldn&rsquo;t be able to access the file system or the internet by default.
In reality, this is easier said than done, but in my opinion, it&rsquo;s only a matter of time until the lack of sandboxing will be exploited.</p><h3 id=hygiene>Hygiene<a hidden class=anchor aria-hidden=true href=#hygiene>#</a></h3><p>Proc-macros are unhygienic, which means that they are affected by the context they are called from.
To avoid naming conflicts, it&rsquo;s recommended to use absolute paths for imports (e.g. <code>::std::thread::spawn</code>).
This works great as long as the required crates can be imported with absolute paths.
However, once another crate re-exports a required crate, a user would usually just import the top-level crate and use its re-export.
Yet, this changes the absolute path of the crate, which in turn breaks the macro.</p><p>Ideally, Rust should be able to recognize paths that are independent from external items and should be evaluated in the context of &ldquo;macro dependencies&rdquo;.
That wouldn&rsquo;t make macros entirely hygienic but certainly less error-prone.</p><h2 id=proc-macro-20>Proc-macro 2.0?<a hidden class=anchor aria-hidden=true href=#proc-macro-20>#</a></h2><p>The compiler team has been aware of issues regarding sandboxing and macro hygiene for a long time now and I hope they will be addressed soon.
However, IDE integration and complex code parsing have been two longstanding issues that were only addressed partially.</p><p>I think it&rsquo;s time to solve these issues properly.</p><h3 id=a-declarative-parsing-description>A declarative parsing description<a hidden class=anchor aria-hidden=true href=#a-declarative-parsing-description>#</a></h3><p>The <a href=https://docs.rs/syn/latest/syn/index.html>syn</a> crate and more recently <a href=https://docs.rs/venial/latest/venial/>venial</a> try to improve macro parsing by defining some structures and functionality to parse them.
Both crates have shown that it is possible to represent macro syntax with Rust&rsquo;s data structures.
However, the compiler still doesn&rsquo;t understand what&rsquo;s going on internally and custom syntax needs manual parsing logic.</p><p>Rust&rsquo;s syntax is documented in the <a href=https://doc.rust-lang.org/reference/notation.html>Rust reference</a> with its own notation.
This implies that it is possible to specify Rust&rsquo;s syntax and probably also the syntax of most macros in a simple format.</p><p>Combining both ideas has huge potential: A simple notation that can be represented by Rust&rsquo;s data structures and read by machines as syntax description would solve both problems.
This notation could be its own lightweight language or just Rust data structures.</p><p>For examples, the compiler could expose some basic parsable types (e.g. structs or trait impls) and derive parsing definitions for custom types.
If all types used by the macro have to let the compiler derive their parsing logic, it would be easy for language servers and the compiler itself to understand the syntax of the macro.
All you need to do then is to tell the Rust compiler where to start parsing and it will return the Rust types corresponding to your syntax description.</p><table><tr><th>Rust reference grammar description</th><th>Derived parsing definition</th></tr><tr><td><pre tabindex=0><code> 


StructField :
   OuterAttribute*
   Visibility?
   IDENTIFIER : Type


 
</code></pre></td><td><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Not just for parsing, also defines a
</span></span></span><span style=display:flex><span><span style=color:#75715e>// syntax description.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Parse)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StructField</span> {
</span></span><span style=display:flex><span>   outer_attr: Vec<span style=color:#f92672>&lt;</span>OuterAttribute<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>   vis: Option<span style=color:#f92672>&lt;</span>Visibility<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>   ident: <span style=color:#a6e22e>Identifier</span>,
</span></span><span style=display:flex><span>   _colon: <span style=color:#a6e22e>Colon</span>,
</span></span><span style=display:flex><span>   ty: <span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></td></tr></table><blockquote><p>Example for describing the syntax of a struct field</p></blockquote><p>The biggest advantage of this approach is that it allows language servers to understand the syntax.
For example, they would know that the macro is looking for code that&rsquo;s a subset of Rust&rsquo;s struct definition.
This gives them much more opportunities to improve IDE integration.</p><h3 id=opaque-tokens>Opaque tokens<a hidden class=anchor aria-hidden=true href=#opaque-tokens>#</a></h3><p>Another improvement for IDE integration would be a concept I call &ldquo;opaque tokens&rdquo;.
When a macro doesn&rsquo;t need to access the value of a token because it doesn&rsquo;t influence the code generation, it could just as well tell the compiler that this token should be opaque.
Opaque tokens would be impossible to access or modify.
This gives language servers the information that a certain token is left unchanged to optimize performance while the user is typing and potentially enable even better IDE integration.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Proc-macros are great as they are, but they have so much more potential.
Rust&rsquo;s third pillar - productivity - will surely profit from easier proc-macros and better IDE integration.</p><p>I hope this article brings up more ideas and discussions to improve the status quo of proc-macros.
Regardless of which solution will be chosen in the end, I believe that proc-macros deserve an upgrade.</p><h1 id=appendix-a-larger-code-example>Appendix: A larger code example<a hidden class=anchor aria-hidden=true href=#appendix-a-larger-code-example>#</a></h1><p>Format description</p><pre tabindex=0><code class=language-noh data-lang=noh>CustomStructStruct :
   struct IDENTIFIER  GenericParams? WhereClause? ( { StructFields? } | ; )

CustomStructFields :
   CustomStructField (, CustomStructField)* ,?

CustomStructField :
   OuterAttribute*
   CustomVisibility?
   IDENTIFIER : Type

CustomVisibility :
      pub
   | pub ( crate )
</code></pre><p>Rust code mockup</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Import existing types from the compiler
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> proc_macro::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Parse)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[subset_of(Struct)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomStruct</span> {
</span></span><span style=display:flex><span>    struct_: <span style=color:#a6e22e>Struct</span>,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>Identifier</span>,
</span></span><span style=display:flex><span>    generics: Option<span style=color:#f92672>&lt;</span>GenericParams<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    where_clause: Option<span style=color:#f92672>&lt;</span>WhereClause<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    inner: <span style=color:#a6e22e>Either</span><span style=color:#f92672>&lt;</span>SemiColon, Backets<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>CustomStructFields<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Parse)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[subset_of(StructFields)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomStructFields</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We don&#39;t want to touch the struct field
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// so we wrap it into `Opaque&lt;T&gt;`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fields: <span style=color:#a6e22e>Punctuated</span><span style=color:#f92672>&lt;</span>Opaque<span style=color:#f92672>&lt;</span>CustomStructField<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Parse)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[subset_of(StructField)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CustomStructField</span> {
</span></span><span style=display:flex><span>    outer_attr: Vec<span style=color:#f92672>&lt;</span>OuterAttribute<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    vis: Option<span style=color:#f92672>&lt;</span>CustomVisibility<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    ident: <span style=color:#a6e22e>Identifier</span>,
</span></span><span style=display:flex><span>    _colon: <span style=color:#a6e22e>Colon</span>,
</span></span><span style=display:flex><span>    ty: <span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Parse)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[subset_of(Visibility)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>CustomVisibility</span> {
</span></span><span style=display:flex><span>   Pub(Pub),
</span></span><span style=display:flex><span>   PubCrate((Pub, Crate)),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://aaronerhardt.github.io/blog/posts/announcing_tuxedo_rs/><span class=title>¬´ Prev</span><br><span>Announcing tuxedo-rs</span></a>
<a class=next href=https://aaronerhardt.github.io/blog/posts/plotters_is_back/><span class=title>Next ¬ª</span><br><span>Plotters is back!</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on twitter" href="https://twitter.com/intent/tweet/?text=Does%20Rust%20need%20proc-macros%202.0%3f&url=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f&title=Does%20Rust%20need%20proc-macros%202.0%3f&summary=Does%20Rust%20need%20proc-macros%202.0%3f&source=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f&title=Does%20Rust%20need%20proc-macros%202.0%3f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on whatsapp" href="https://api.whatsapp.com/send?text=Does%20Rust%20need%20proc-macros%202.0%3f%20-%20https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Does Rust need proc-macros 2.0? on telegram" href="https://telegram.me/share/url?text=Does%20Rust%20need%20proc-macros%202.0%3f&url=https%3a%2f%2faaronerhardt.github.io%2fblog%2fposts%2fproc_macro_v2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://aaronerhardt.github.io/blog/>Eberhardt blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>