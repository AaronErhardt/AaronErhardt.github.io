<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Components - GUI development with Relm4</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="first_app.html"><strong aria-hidden="true">1.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="widget_macro.html"><strong aria-hidden="true">2.</strong> The widget macro</a></li><li class="chapter-item expanded "><a href="efficient_ui.html"><strong aria-hidden="true">3.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tracker.html"><strong aria-hidden="true">3.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="factory.html"><strong aria-hidden="true">3.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="factory_position.html"><strong aria-hidden="true">3.3.</strong> The position function</a></li><li class="chapter-item expanded "><a href="factory_advanced.html"><strong aria-hidden="true">3.4.</strong> Advanced factories</a></li></ol></li><li class="chapter-item expanded "><a href="components.html" class="active"><strong aria-hidden="true">4.</strong> Components</a></li><li class="chapter-item expanded "><a href="worker.html"><strong aria-hidden="true">5.</strong> Workers</a></li><li class="chapter-item expanded "><a href="message_handler.html"><strong aria-hidden="true">6.</strong> Message handlers</a></li><li class="chapter-item expanded "><a href="threads_and_async.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li class="chapter-item expanded "><a href="reusable_components.html"><strong aria-hidden="true">8.</strong> Reusable components</a></li><li class="chapter-item expanded "><a href="gtk_rs.html"><strong aria-hidden="true">9.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="widget_macro_reference.html"><strong aria-hidden="true">10.</strong> Widget macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widget_macro_expansion.html"><strong aria-hidden="true">10.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="templates.html"><strong aria-hidden="true">11.</strong> Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app_template.html"><strong aria-hidden="true">11.1.</strong> App template</a></li><li class="chapter-item expanded "><a href="component_template.html"><strong aria-hidden="true">11.2.</strong> Component template</a></li><li class="chapter-item expanded "><a href="worker_template.html"><strong aria-hidden="true">11.3.</strong> Worker template</a></li></ol></li><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">12.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="0_2_to_0_4.html"><strong aria-hidden="true">12.1.</strong> 0.2 to 0.4</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AaronErhardt/AaronErhardt.github.io/tree/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>I've already mentioned components several times in the previous chapters. Now we'll finally have a look at them.</p>
<p>In short, components are independent parts of your application that can communicate with each other through messages. They are used in a parent-child model: The main app can have components and each component can have child components that again can have child components. This means that each component has a parent, whereas the main app is at the top of this tree structure and therefore does not have a parent. Also, each component can send and receive messages from both parent and children.</p>
<p>To showcase this, we will create a small application which opens a dialog when it gets closed. The headerbar and the dialog will be implemented as standalone components. The communication to the main application will be done via messages.</p>
<p><img src="img/screenshots/components-dark-1.png" alt="App screenshot dark" /></p>
<p><img src="img/screenshots/components-dark-2.png" alt="App screenshot dark" /></p>
<h2 id="when-to-use-components"><a class="header" href="#when-to-use-components">When to use components</a></h2>
<p>Components are mainly useful for separating parts of the UI into smaller, more manageable parts. They are not necessary but for larger applications, they can be very helpful.</p>
<h1 id="example-application"><a class="header" href="#example-application">Example application</a></h1>
<p>Let's write a small example app to see how components can be used in action. For this example, we write parts of an app that can edit images.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/components.rs">here</a>. Run <code>cargo run --example components</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-header-bar"><a class="header" href="#the-header-bar">The header bar</a></h2>
<p>Our first component will be a header bar. There are not a lot of advantages for writing this component except for reducing the complexity in other parts of our UI.</p>
<p>The header bar will have three buttons for three modes that our application can have:</p>
<ul>
<li><strong>View:</strong> View the image.</li>
<li><strong>Edit:</strong> Edit the image.</li>
<li><strong>Export:</strong> Export the image in different formats.</li>
</ul>
<p>We will not implement the actual functionality, but use placeholders instead to keep things simple.</p>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>Usually you want to store everything that only affects your component in the state of the component. In this case however, there is no state that can be stored in the component, but only a state that affects the root component (app). Therefore, we leave the model empty and only send messages to the root component.</p>
<pre><code class="language-rust no_run noplayground">struct HeaderModel {}
</code></pre>
<p>The message type allows us to switch between the modes.</p>
<pre><code class="language-rust no_run noplayground">enum HeaderMsg {
    View,
    Edit,
    Export,
}
</code></pre>
<p>For components we also need to implement the <code>Model</code> trait. The <code>Components</code> type is empty here because it refers to child components. We don't have any child components for our header bar so we use a <code>()</code>.</p>
<pre><code class="language-rust no_run noplayground">impl Model for HeaderModel {
    type Msg = HeaderMsg;
    type Widgets = HeaderWidgets;
    type Components = ();
}
</code></pre>
<p>The update function is rather minimal. If our header bar were more complex, storing state in this component would make sense, but because we just handle a few buttons, we can simply forward messages. For that we can use the <code>parent_sender</code>. You can see that the message type of the main application is <code>AppMsg</code> and that there's an enum <code>AppMode</code>. Both were not introduced yet, but will be explained later. For now, we just need to know that this component will send <code>SetMode</code> messages to the app.</p>
<pre><code class="language-rust no_run noplayground">impl ComponentUpdate&lt;AppModel&gt; for HeaderModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        HeaderModel {}
    }

    fn update(
        &amp;mut self,
        msg: HeaderMsg,
        _components: &amp;(),
        _sender: Sender&lt;HeaderMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            HeaderMsg::View =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::View));
            }
            HeaderMsg::Edit =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Edit));
            }
            HeaderMsg::Export =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Export));
            }
        }
    }
}
</code></pre>
<blockquote>
<p>We don't use the <code>_parent_model</code> argument of the <code>init_model</code> in this example. Yet you can use it if you need to access information from the parent model during initialization, for example for passing a resource shared with the component.</p>
</blockquote>
<h3 id="the-widgets"><a class="header" href="#the-widgets">The widgets</a></h3>
<p>There's nothing special about widgets of a component. The only difference to the main app is that the root widget doesn't need to be a <code>gtk::ApplicationWindow</code>. Instead, we use a <code>gtk::HeaderBar</code> here, but theoretically the root widget doesn't even need to be a widget at all (which can be useful in special cases).</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;HeaderModel, AppModel&gt; for HeaderWidgets {
    view! {
        gtk::HeaderBar {
            set_title_widget = Some(&amp;gtk::Box) {
                add_css_class: &quot;linked&quot;,
                append: group = &amp;gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::View);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Edit);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Export);
                        }
                    },
                },
            }
        }
    }
}
</code></pre>
<h2 id="the-close-alert"><a class="header" href="#the-close-alert">The close alert</a></h2>
<p>Like a normal application that's used to edit files, we want to notify the user before accidentally closing the application and discarding all progress. For this — you might have guessed it already — we will use another component.</p>
<h3 id="the-model-1"><a class="header" href="#the-model-1">The model</a></h3>
<p>The state of the dialog only needs to store whether or not it's hidden.</p>
<pre><code class="language-rust no_run noplayground">struct DialogModel {
    hidden: bool,
}
</code></pre>
<p>The message contains three options:</p>
<ul>
<li>Show is used by the parent to display the dialog.</li>
<li>Accept is used internally to indicate that the user agreed to close the application.</li>
<li>Cancel is used internally to indicate that the user changes his mind and doesn't want to close the application.</li>
</ul>
<pre><code class="language-rust no_run noplayground">enum DialogMsg {
    Show,
    Accept,
    Cancel,
}
</code></pre>
<p>The update function updates the state of the dialog and sends a close message if the user accepted.</p>
<pre><code class="language-rust no_run noplayground">impl ComponentUpdate&lt;AppModel&gt; for DialogModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        DialogModel { hidden: true }
    }

    fn update(
        &amp;mut self,
        msg: DialogMsg,
        _components: &amp;(),
        _sender: Sender&lt;DialogMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            DialogMsg::Show =&gt; self.hidden = false,
            DialogMsg::Accept =&gt; {
                self.hidden = true;
                send!(parent_sender, AppMsg::Close);
            }
            DialogMsg::Cancel =&gt; self.hidden = true,
        }
    }
}
</code></pre>
<h3 id="the-widgets-1"><a class="header" href="#the-widgets-1">The widgets</a></h3>
<p>You've probably seen enough widget implementations by now to know roughly how this should look like, but because we haven't had window components let's have a look at it either way.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;DialogModel, AppModel&gt; for DialogWidgets {
    view! {
        gtk::MessageDialog {
            set_transient_for: Some(&amp;parent_widgets.main_window),
            set_modal: true,
            set_visible: watch!(!model.hidden),
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: args!(&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: args!(&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response(sender) =&gt; move |_, resp| {
                send!(sender, if resp == gtk::ResponseType::Accept {
                    DialogMsg::Accept
                } else {
                    DialogMsg::Cancel
                });
            }
        }
    }
}
</code></pre>
<p>Most notably there is the <code>args!</code> macro. It allows us to pass values to functions that take more than one argument. The macro would otherwise interpret the comma for a second argument as a new property, so we need to use <code>args!</code> here.</p>
<p>Also, we set the <code>set_transient_for</code> property, which actually uses the main window from the parent widgets. So far <code>parent_widgets</code> was an unused argument in our implementations. However in this case, it's neat to have access to the parent widgets. The dialog should set his parent window so that GTK can handle the dialog better. The GTK docs state: &quot;[set_transient_for] allows window managers to e.g. keep the dialog on top of the main window, or center the dialog over the main window&quot;. So we definitely want that and conveniently Relm4 gives us the widgets we need from the parents.</p>
<h2 id="the-main-app"><a class="header" href="#the-main-app">The main app</a></h2>
<p>Now all parts come together to form a single app. You might remember that there was a components type we always set to <code>()</code>. Now we actually make use of this type.</p>
<h3 id="the-components"><a class="header" href="#the-components">The components</a></h3>
<p>Because each app and each component can have any amount of child components we need to define a struct that stores all of our components.</p>
<pre><code class="language-rust no_run noplayground">struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}
</code></pre>
<p>To do this, just implement a struct with the components wrapped into a <code>RelmComponent</code> (which is similar to <code>RelmApp</code>). The first generic type of <code>RelmComponent</code> is the model of the component and the second one the parent model.</p>
<p>To make this work and to initialize our components, we need to implement the <code>Components</code> trait for our struct.</p>
<pre><code class="language-rust no_run noplayground">impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::new(parent_model, parent_widgets, parent_sender),
        }
    }
}
</code></pre>
<p>We just need to pass the arguments of the <code>init_components</code> function over to the <code>RelmComponent::new</code> function and the rest will be handled by Relm4.</p>
<h3 id="the-model-2"><a class="header" href="#the-model-2">The model</a></h3>
<p>Now we're looking at something familiar again, the model of the main app.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
}
</code></pre>
<p>The <code>AppModel</code> struct stores the modes the application can be in. The <code>SetMode</code> message is used by our header bar component to update the state of the main application when someone presses a button in the header bar. The <code>Close</code> message is used by the dialog component to indicate that the window should be closed.</p>
<p>And now we finally use the <code>Components</code> type of the <code>Model</code> trait.</p>
<pre><code class="language-rust no_run noplayground">impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}
</code></pre>
<p>The update function of the model is pretty straight forward.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, components: &amp;AppComponents, _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                components.dialog.send(DialogMsg::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                return false;
            }
        }
        true
    }
}
</code></pre>
<p>You see we can use <code>components.NAME.send()</code> to send messages to a child component, similar to the parent_sender we used to send messages in the other direction. Also we return <code>false</code> if our dialog component sends the <code>Close</code> message to tell Relm4 to close the application.</p>
<h3 id="the-widgets-2"><a class="header" href="#the-widgets-2">The widgets</a></h3>
<p>We're almost done! We only need to define the widgets of the main app.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: component!(Some(components.header.root_widget())),
            set_child = Some(&amp;gtk::Label) {
                set_label: watch!(&amp;format!(&quot;Placeholder for {:?}&quot;, model.mode)),
            },
            connect_close_request(sender) =&gt; move |_| {
                send!(sender, AppMsg::CloseRequest);
                gtk::Inhibit(true)
            }
        }
    }
}
</code></pre>
<p>The <code>component!</code> macro is used to interact with components. We just need to get our header bar component in place. Our dialog component does not need to be attached anywhere because the dialog lives in a separate window.</p>
<blockquote>
<p>Widgets from components are added <strong>after</strong> everything else. Because Relm4 initializes components after their parents we can only add components after the rest is already in place. This means that you sometimes might have to use methods like <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.BoxExt.html#tymethod.prepend"><code>prepend</code></a> to keep the right order because with <code>append</code> the component will always be added at the end. Yet, everything else is initialized in the right order.</p>
</blockquote>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>You now know most of the secrets that Relm4 offers. Components can be powerful and if they are implemented correctly, they are even reusable across different apps. The relm4-components crate offers several reusable components you can use in your applications. In the following chapters, we'll look at an even simpler component type called worker, how to implement reusable components yourself and how to use components with async code and multiple threads.</p>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, DialogExt, GtkWindowExt, ToggleButtonExt, WidgetExt};
use relm4::Sender;
use relm4::*;

enum HeaderMsg {
    View,
    Edit,
    Export,
}

struct HeaderModel {}

impl Model for HeaderModel {
    type Msg = HeaderMsg;
    type Widgets = HeaderWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for HeaderModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        HeaderModel {}
    }

    fn update(
        &amp;mut self,
        msg: HeaderMsg,
        _components: &amp;(),
        _sender: Sender&lt;HeaderMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            HeaderMsg::View =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::View));
            }
            HeaderMsg::Edit =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Edit));
            }
            HeaderMsg::Export =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Export));
            }
        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;HeaderModel, AppModel&gt; for HeaderWidgets {
    view! {
        gtk::HeaderBar {
            set_title_widget = Some(&amp;gtk::Box) {
                add_css_class: &quot;linked&quot;,
                append: group = &amp;gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::View);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Edit);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Export);
                        }
                    },
                },
            }
        }
    }
}

struct DialogModel {
    hidden: bool,
}

enum DialogMsg {
    Show,
    Accept,
    Cancel,
}

impl Model for DialogModel {
    type Msg = DialogMsg;
    type Widgets = DialogWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for DialogModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        DialogModel { hidden: true }
    }

    fn update(
        &amp;mut self,
        msg: DialogMsg,
        _components: &amp;(),
        _sender: Sender&lt;DialogMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            DialogMsg::Show =&gt; self.hidden = false,
            DialogMsg::Accept =&gt; {
                self.hidden = true;
                send!(parent_sender, AppMsg::Close);
            }
            DialogMsg::Cancel =&gt; self.hidden = true,
        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;DialogModel, AppModel&gt; for DialogWidgets {
    view! {
        gtk::MessageDialog {
            set_transient_for: Some(&amp;parent_widgets.main_window),
            set_modal: true,
            set_visible: watch!(!model.hidden),
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: args!(&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: args!(&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response(sender) =&gt; move |_, resp| {
                send!(sender, if resp == gtk::ResponseType::Accept {
                    DialogMsg::Accept
                } else {
                    DialogMsg::Cancel
                });
            }
        }
    }
}

struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::new(parent_model, parent_widgets, parent_sender),
        }
    }
}

#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: component!(Some(components.header.root_widget())),
            set_child = Some(&amp;gtk::Label) {
                set_label: watch!(&amp;format!(&quot;Placeholder for {:?}&quot;, model.mode)),
            },
            connect_close_request(sender) =&gt; move |_| {
                send!(sender, AppMsg::CloseRequest);
                gtk::Inhibit(true)
            }
        }
    }
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, components: &amp;AppComponents, _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                components.dialog.send(DialogMsg::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                return false;
            }
        }
        true
    }
}

fn main() {
    let model = AppModel {
        mode: AppMode::View,
    };
    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="factory_advanced.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="worker.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="factory_advanced.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="worker.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
