<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GUI development with Relm4</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="first_app.html"><strong aria-hidden="true">1.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="widget_macro.html"><strong aria-hidden="true">2.</strong> The widget macro</a></li><li class="chapter-item expanded "><a href="efficient_ui.html"><strong aria-hidden="true">3.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tracker.html"><strong aria-hidden="true">3.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="factory.html"><strong aria-hidden="true">3.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="factory_position.html"><strong aria-hidden="true">3.3.</strong> The position function</a></li><li class="chapter-item expanded "><a href="factory_advanced.html"><strong aria-hidden="true">3.4.</strong> Advanced factories</a></li></ol></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">4.</strong> Components</a></li><li class="chapter-item expanded "><a href="worker.html"><strong aria-hidden="true">5.</strong> Workers</a></li><li class="chapter-item expanded "><a href="message_handler.html"><strong aria-hidden="true">6.</strong> Message handlers</a></li><li class="chapter-item expanded "><a href="threads_and_async.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li class="chapter-item expanded "><a href="reusable_components.html"><strong aria-hidden="true">8.</strong> Reusable components</a></li><li class="chapter-item expanded "><a href="gtk_rs.html"><strong aria-hidden="true">9.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="widget_macro_reference.html"><strong aria-hidden="true">10.</strong> Widget macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widget_macro_expansion.html"><strong aria-hidden="true">10.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="templates.html"><strong aria-hidden="true">11.</strong> Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app_template.html"><strong aria-hidden="true">11.1.</strong> App template</a></li><li class="chapter-item expanded "><a href="component_template.html"><strong aria-hidden="true">11.2.</strong> Component template</a></li><li class="chapter-item expanded "><a href="worker_template.html"><strong aria-hidden="true">11.3.</strong> Worker template</a></li></ol></li><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">12.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="0_2_to_0_4.html"><strong aria-hidden="true">12.1.</strong> 0.2 to 0.4</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AaronErhardt/AaronErhardt.github.io/tree/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>
  <img src="img/Relm_logo_with_text.png" width="190" alt="Relm4">
</h1>
<p><a href="https://matrix.to/#/#relm4:matrix.org"><img src="https://img.shields.io/matrix/relm4:matrix.org?label=matrix%20chat" alt="Matrix" /></a>
<a href="https://crates.io/crates/relm4"><img src="https://img.shields.io/crates/v/relm4.svg" alt="Relm4 on crates.io" /></a>
<a href="https://aaronerhardt.github.io/docs/relm4/relm4/"><img src="https://img.shields.io/badge/rust-documentation-blue" alt="Relm4 docs" /></a></p>
<p>Relm4 is an idiomatic GUI library inspired by <a href="https://elm-lang.org/">Elm</a> and based on <a href="https://crates.io/crates/gtk4">gtk4-rs</a>. 
It is a new version of <a href="https://github.com/antoyo/relm">relm</a> that's built from scratch and is compatible with <a href="https://www.gtk.org/">GTK4</a> and <a href="https://gitlab.gnome.org/GNOME/libadwaita">libadwaita</a>.</p>
<h2 id="why-relm4"><a class="header" href="#why-relm4">Why Relm4</a></h2>
<p>We believe that GUI development should be easy, productive and delightful.<br />
The <a href="https://crates.io/crates/gtk4">gtk4-rs</a> crate already provides everything you need to write modern, beautiful and cross-platform applications.
Built on top of this foundation, Relm4 makes developing more idiomatic, simpler and faster and enables you to become productive in just a few hours.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To work with Relm4, you should understand most basic language features of the Rust programming language. We recommend to at least be familiar with the content of the chapters 1, 3-6, 8, 10 and 13 of the <a href="https://doc.rust-lang.org/stable/book/title-page.html">Rust book</a>.</p>
<p>I also recommend reading the <a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk4-rs book</a> for getting more insight into development with gtk4-rs. Yet, knowledge of GTK4 or gtk4-rs is not required in this book.</p>
<p><strong>Helpful links:</strong></p>
<ul>
<li><a href="https://gtk-rs.org/gtk4-rs/git/book/installation.html">How to install GTK4 for Rust</a></li>
<li><a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk4-rs book</a></li>
<li><a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/index.html">gtk4-rs docs</a></li>
</ul>
<p><strong>Cargo:</strong></p>
<p>Add the packages you need to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">gtk = { version = &quot;0.3&quot;, package = &quot;gtk4&quot; }
relm4 = &quot;0.2&quot;
relm4-macros = &quot;0.2&quot;
relm4-components = &quot;0.2&quot;
</code></pre>
<h2 id="issues-and-feedback"><a class="header" href="#issues-and-feedback">Issues and feedback</a></h2>
<p>If you find a mistake or something unclear in Relm4 or this book, let me know! Simply open up an issue over at <a href="https://github.com/AaronErhardt/relm4/issues">GitHub</a> or chat with us on <a href="https://matrix.to/#/#relm4:matrix.org">Matrix</a>.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform support</a></h2>
<p>All platforms supported by GTK4 are available for Relm4 as well:</p>
<ul>
<li>Linux</li>
<li>Windows</li>
<li>MacOS</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>If you prefer learning directly from examples, we got you covered!</p>
<p>Many code examples in this book and many other examples can also be found in the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">relm4-examples crate</a>. Whenever an example is discussed in the book, the introduction will mention the name of the example and provide a link to it.</p>
<p>To setup the examples run</p>
<pre><code class="language-bash">git clone https://github.com/AaronErhardt/relm4.git
cd relm4
cd relm4-examples
</code></pre>
<p>And to run an example, simply type</p>
<pre><code>cargo run --example NAME
</code></pre>
<h3 id="screenshots"><a class="header" href="#screenshots">Screenshots</a></h3>
<p>As a sneak peak here are screenshots of some examples.</p>
<table><thead><tr><th style="text-align: center">Light Theme</th><th style="text-align: center">Dark Theme</th></tr></thead><tbody>
<tr><td style="text-align: center"><img src="img/screenshots/popover-light.png" alt="Pop Over light" /></td><td style="text-align: center"><img src="img/screenshots/popover-dark.png" alt="Pop Over dark" /></td></tr>
<tr><td style="text-align: center"><img src="img/screenshots/factory-advanced-light.png" alt="Factory-Advanced light" /></td><td style="text-align: center"><img src="img/screenshots/factory-advanced-dark.png" alt="Factory-Advanced dark" /></td></tr>
</tbody></table>
<h1 id="special-thanks"><a class="header" href="#special-thanks">Special thanks</a></h1>
<p>I want to thank all contributors of <a href="https://github.com/antoyo/relm">relm</a> especially <a href="https://github.com/antoyo">antoyo</a> for building relm that inspired much of the work on Relm4.</p>
<p>Also, I want to thank all contributors of <a href="https://gtk-rs.org/">gtk-rs</a> that put a lot of effort into the project for creating outstanding Rust bindings for GTK4.</p>
<p>I want to thank <a href="https://github.com/tronta">tronta</a> for contributing a lot of improvements to this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-app"><a class="header" href="#your-first-app">Your first app</a></h1>
<p>For our first app, let's create something original: a counter app.</p>
<p><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></p>
<p>In this app, we will have a counter which can be incremented and decremented by pressing the corresponding buttons.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/simple_manual.rs">here</a>. Run <code>cargo run --example simple_manual</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="application-architecture"><a class="header" href="#application-architecture">Application architecture</a></h2>
<p>Often, programming concepts are easier to understand when explained with examples or metaphors from the real world. To understand how Relm4 apps work, you can think about a computer as a person.</p>
<p>Our job as a programmer is to ensure that the users of our app will be able to communicate with the computer through the UI. Since the computer can't understand our human language, it needs some help from us to get the communication going. </p>
<p>Let's have a look at what we need to get this done!</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>To help the computer understand what we want to tell it, we first translate user interactions into messages.</p>
<p>In Relm4, a message can be any data type, but most often, an <code>enum</code> is used. In our case, we just want to tell the computer to either increment or decrement a counter.</p>
<pre><code class="language-rust no_run noplayground">enum AppMsg {
    Increment,
    Decrement,
}
</code></pre>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>Like a person, a computer needs a brain to be functional. It needs to process our messages and remember the results.</p>
<p>Relm4 uses the term <code>Model</code> as a data type that represents the application state, the memory of your application. For our counter app, the computer only needs to remember the counter value, so an <code>u8</code> is all we need.</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
}
</code></pre>
<h3 id="the-appupdate-trait"><a class="header" href="#the-appupdate-trait">The <code>AppUpdate</code> trait</a></h3>
<p>Of course, the brain needs to do more than just remembering things, it also needs to process information.</p>
<p>Here, both the model and message types come into play. The <code>update</code> function of the <code>AppUpdate</code> trait tells the computer how to process messages and how to update its memory.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}
</code></pre>
<blockquote>
<p><code>wrapping_add(1)</code> and <code>wrapping_sub(1)</code> are like <code>+1</code>  and <code>-1</code>, but don't panic on overflows.</p>
</blockquote>
<p>Also, we return <code>true</code> to tell the computer to keep our application alive. If our app should close, we can simply return <code>false</code>.</p>
<h3 id="the-widgets"><a class="header" href="#the-widgets">The widgets</a></h3>
<p>The computer is now able to process and remember information, but we still need an interface to communicate with the user.</p>
<p>GTK4 offers the computer widgets that allow it to take input and to respond. Widgets are simply parts of an UI like buttons, input fields or text areas. To be able to update the widgets in our program, we can put them all into a <code>struct</code>.</p>
<p>For our app, we use a window with two buttons to increment and decrement the counter and a label to display the counter value. Besides that, we need a box as a container to place our buttons and the label inside because a window can only have one child.</p>
<pre><code class="language-rust no_run noplayground">struct AppWidgets {
    window: gtk::ApplicationWindow,
    vbox: gtk::Box,
    inc_button: gtk::Button,
    dec_button: gtk::Button,
    label: gtk::Label,
}
</code></pre>
<h3 id="the-widgets-trait"><a class="header" href="#the-widgets-trait">The <code>Widgets</code> trait</a></h3>
<p>The last step is to tell the computer how to initialize widgets and how to update them.</p>
<p>In Relm4, the UI represents the memory of the application. All that's left to do is to implement the <code>Widgets</code> trait that tells the computer exactly how its memory should be visualized.</p>
<p>Let's do this step by step. First, we'll have a look at the beginning of the trait <code>impl</code>.</p>
<pre><code class="language-rust no_run noplayground">impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;
</code></pre>
<p>The two generic parameters are our model and the parent model. We're at the root of our app so we don't have a parent model and can use <code>()</code> as placeholder.</p>
<p>The <code>Root</code> type is the outermost widget of the app. Components can choose this type freely, but the main application must use an <code>ApplicationWindow</code>.</p>
<p>Next up, we want to initialize our UI.</p>
<blockquote>
<p>Don't worry about the amount of manual code you need for handling widgets. In the next chapter, we'll see how this can be done easier.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">    /// Initialize the UI.
    fn init_view(model: &amp;AppModel, _parent_widgets: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let window = gtk::ApplicationWindow::builder()
            .title(&quot;Simple app&quot;)
            .default_width(300)
            .default_height(100)
            .build();
        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();
        vbox.set_margin_all(5);

        let inc_button = gtk::Button::with_label(&quot;Increment&quot;);
        let dec_button = gtk::Button::with_label(&quot;Decrement&quot;);

        let label = gtk::Label::new(Some(&amp;format!(&quot;Counter: {}&quot;, model.counter)));
        label.set_margin_all(5);

        // Connect the widgets
        window.set_child(Some(&amp;vbox));
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        // Connect events
        let btn_sender = sender.clone();
        inc_button.connect_clicked(move |_| {
            send!(btn_sender, AppMsg::Increment);
        });

        dec_button.connect_clicked(move |_| {
            send!(sender, AppMsg::Decrement);
        });

        Self {
            window,
            vbox,
            inc_button,
            dec_button,
            label,
        }
    }
</code></pre>
<p>First, we initialize each of our widgets, mostly by using builder patterns.</p>
<p>Then we connect the widgets so that GTK4 knows how they are related to each other. The buttons and the label are added as children of the box, and the box is added as the child of the window.</p>
<p>Next, we connect the &quot;clicked&quot; event for both buttons and send a message from the closures to the computer. To do this, we only need to move a cloned sender into the closures and send the message. Now every time we click our buttons, a message will be sent to update our counter!</p>
<p>Still our UI will not update when the counter is changed. To do this, we need to implement the view function that modifies the UI according to the changes in the model.</p>
<pre><code class="language-rust no_run noplayground">    /// Update the view to represent the updated model.
    fn view(&amp;mut self, model: &amp;AppModel, _sender: Sender&lt;AppMsg&gt;) {
        self.label.set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));
    }
</code></pre>
<p>We're almost done. To complete the <code>Widgets</code> trait, we just need to implement the <code>root_widget</code> method that simply returns the <code>Root</code>.</p>
<pre><code class="language-rust no_run noplayground">    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.window.clone()
    }
</code></pre>
<h3 id="the-model-trait"><a class="header" href="#the-model-trait">The <code>Model</code> trait</a></h3>
<p>In the <code>Model</code> trait, everything comes together. This trait just describes how the types we defined work together.</p>
<pre><code class="language-rust no_run noplayground">impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}
</code></pre>
<h2 id="running-the-app"><a class="header" href="#running-the-app">Running the App</a></h2>
<p>The last step is to run the app we just wrote. To do so, we just need to initialize our model and pass it into <code>RelmApp::new()</code>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let model = AppModel { counter: 0 };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<p>ðŸŽ‰ Congratulations! You just wrote your first app with Relm4! ðŸŽ‰</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Let's summarize what we learned in this chapter.</p>
<p>A Relm4 application has three important types:</p>
<ol>
<li>The model type that stores the application state, the memory of our app.</li>
<li>The message type that describes which information can be sent to update the model.</li>
<li>The widgets type that stores our widgets.</li>
</ol>
<p>Also, there are two important functions:</p>
<ol>
<li><code>update</code> receives a message and updates the model accordingly.</li>
<li><code>view</code> receives the updated model and updates the widgets accordingly.</li>
</ol>
<p>The app does all those things in a loop. It waits for messages and once a message is received, it runs <code>update</code> and then <code>view</code>.</p>
<p><img src="img/update_loop.svg" alt="relm update loop" /></p>
<blockquote>
<p>Relm4 separates the data and the UI. The UI never knows which message was sent, but can only read the model. This might seem like a limitation, but it helps you to create maintainable, stable and consistent applications.</p>
</blockquote>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>I hope this chapter made everything clear for you :)</p>
<p>If you found a mistake or there was something unclear, please open an issue <a href="https://github.com/AaronErhardt/relm4/issues">here</a>.</p>
<p>As you have seen, initializing the UI was by far the largest part of our app, with roughly one half of the total code. In the next chapter, we will have a look at the <code>relm4-macros</code> crate that offers a macro that helps us to reduce the amount of code we need to implement the Widgets trait.</p>
<blockquote>
<p>As you might have noticed, storing <code>inc_button</code>, <code>dec_button</code> and <code>vbox</code> in our widgets <code>struct</code> is not necessary because GTK will keep them alive automatically. Therefore, we can remove them from <code>AppWidgets</code> to avoid compiler warnings.</p>
</blockquote>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt};
use relm4::{send, AppUpdate, Model, RelmApp, Sender, WidgetPlus, Widgets};

struct AppModel {
    counter: u8,
}

enum AppMsg {
    Increment,
    Decrement,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}

struct AppWidgets {
    window: gtk::ApplicationWindow,
    vbox: gtk::Box,
    inc_button: gtk::Button,
    dec_button: gtk::Button,
    label: gtk::Label,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;

    /// Initialize the UI.
    fn init_view(model: &amp;AppModel, _parent_widgets: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let window = gtk::ApplicationWindow::builder()
            .title(&quot;Simple app&quot;)
            .default_width(300)
            .default_height(100)
            .build();
        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();
        vbox.set_margin_all(5);

        let inc_button = gtk::Button::with_label(&quot;Increment&quot;);
        let dec_button = gtk::Button::with_label(&quot;Decrement&quot;);

        let label = gtk::Label::new(Some(&amp;format!(&quot;Counter: {}&quot;, model.counter)));
        label.set_margin_all(5);

        // Connect the widgets
        window.set_child(Some(&amp;vbox));
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        // Connect events
        let btn_sender = sender.clone();
        inc_button.connect_clicked(move |_| {
            send!(btn_sender, AppMsg::Increment);
        });

        dec_button.connect_clicked(move |_| {
            send!(sender, AppMsg::Decrement);
        });

        Self {
            window,
            vbox,
            inc_button,
            dec_button,
            label,
        }
    }

    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.window.clone()
    }

    /// Update the view to represent the updated model.
    fn view(&amp;mut self, model: &amp;AppModel, _sender: Sender&lt;AppMsg&gt;) {
        self.label.set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));
    }
}

fn main() {
    let model = AppModel { counter: 0 };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-widget-macro"><a class="header" href="#the-widget-macro">The widget macro</a></h1>
<p>To simplify the implementation of the <code>Widgets</code> trait, let's use the relm4-macros crate!</p>
<p><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></p>
<p>The app will look and behave identical to our first app from the previous chapter. Only the implementation is different.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/simple.rs">here</a>. Run <code>cargo run --example simple</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="whats-different"><a class="header" href="#whats-different">What's different</a></h2>
<p>The <code>widgets</code> macro will take care of creating the widgets <code>struct</code> and will also implement the <code>Widgets</code> trait for us. All other parts of the code remain untouched, so we can reuse most of the code from the previous chapter.</p>
<p>Let's have a look at the macro and go through the code step by step:</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        gtk::ApplicationWindow {
            set_title: Some(&quot;Simple app&quot;),
            set_default_width: 300,
            set_default_height: 100,
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,

                append = &amp;gtk::Button {
                    set_label: &quot;Increment&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Increment);
                    },
                },
                append = &amp;gtk::Button::with_label(&quot;Decrement&quot;) {
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Decrement);
                    },
                },
                append = &amp;gtk::Label {
                    set_margin_all: 5,
                    set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
                }
            },
        }
    }
}
</code></pre>
<p>The first line doesn't change. We still have to define what's the model and what's the parent model. The only difference is that the struct <code>AppWidgets</code> is never explicitly defined in the code, but generated by the macro.</p>
<p>And then... wait, where do we define the <code>Root</code> type? Actually, the macro knows that your outermost widget is going to be the root widget.</p>
<p>Next up - the heart of the <code>widget</code> macro - the nested <code>view!</code> macro. Here, we can easily define widgets and assign properties to them.</p>
<h3 id="properties"><a class="header" href="#properties">Properties</a></h3>
<p>As you see, we start with the <code>gtk::ApplicationWindow</code> which is our root. Then we open up brackets and assign properties to the window. There's not much magic here but actually <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.GtkWindowExt.html#tymethod.set_title"><code>set_title</code></a> is a method provided by gtk4-rs. So technically, the macro creates code like this:</p>
<pre><code class="language-rust no_run noplayground">window.set_title(Some(&quot;Simple app&quot;));
</code></pre>
<h3 id="widgets"><a class="header" href="#widgets">Widgets</a></h3>
<p>Eventually, we assign a new widget to the window.</p>
<pre><code class="language-rust no_run noplayground">            set_child = Some(&amp;gtk::Box) {
</code></pre>
<p>The only difference to assigning properties is that we use <code>=</code> instead of <code>:</code>. We could also name widgets using the <code>method: name = Widget</code> syntax:</p>
<pre><code class="language-rust no_run noplayground">            set_child: vbox = Some(&amp;gtk::Box) {
</code></pre>
<p>Sometimes we want to use a constructor function to initialize our widgets. For the second button we used the <code>gtk::Button::with_label</code> function. This function returns a new button with the &quot;Decrement&quot; label already set, so we don't have to call <code>set_label</code> afterwards.</p>
<pre><code class="language-rust no_run noplayground">                append = &amp;gtk::Button::with_label(&quot;Decrement&quot;) {
</code></pre>
<h3 id="returned-widget-syntax"><a class="header" href="#returned-widget-syntax">Returned Widget Syntax</a></h3>
<p>Some methods also return a newly created widget which we want to adjust to our needs.
E.g. <code>Stack</code>'s <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.Stack.html#method.add_child"><code>add_child</code></a> method returns a <code>StackPage</code> where we can set if the page needs <a href="https://gtk-rs.org/gtk4-rs/stable/latest/docs/gtk4/struct.StackPage.html#method.set_needs_attention">special user attention</a>:</p>
<p><img src="img/stack_switcher.png" alt="App screenshot dark" /></p>
<p>To enable this, there is an extension of the described syntax, where we can apply additional changes to the returned widget:</p>
<pre><code class="language-rust no_run noplayground">add_child = &amp;gtk::Label {
    set_label: &quot;00:00:00&quot;,
} -&gt; {
    set_title: &quot;Stopwatch&quot;,
    set_needs_attention: true,
    set_batch_number: 3,
},
</code></pre>
<p>Cases when an <code>Option&lt;Widget&gt;</code> is returned can be handled by the following:</p>
<pre><code class="language-rust no_run noplayground">{ ... } -&gt; ? { ... },
</code></pre>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>To connect events, we use this syntax.</p>
<pre><code class="language-rust no_run noplayground">method_name(cloned_var1, cloned_var2, ...) =&gt; move |args, ...| { code... }
</code></pre>
<p>Again, there's no magic. The macro will simply assign a closure to a method. Because closures often need to capture local variables that don't implement the <code>Copy</code> trait, we need to clone these variables. Therefore, we can list the variables we want to clone in the parentheses after the method name.</p>
<pre><code class="language-rust no_run noplayground">                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Increment);
                    },
</code></pre>
<h3 id="ui-updates"><a class="header" href="#ui-updates">UI updates</a></h3>
<p>The last special syntax of the <code>widgets</code> macro we'll cover here is the <code>watch!</code> macro. It's just like the normal initialization except that it also updates the property in the view function. Without it, the counter label would never be updated.</p>
<pre><code class="language-rust no_run noplayground">                    set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
</code></pre>
<blockquote>
<p>The full reference for the syntax of the widget macro can be found <a href="https://aaronerhardt.github.io/relm4-book/book/widget_macro_reference.html">here</a>.</p>
</blockquote>
<h2 id="the-complete-code-1"><a class="header" href="#the-complete-code-1">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{send, AppUpdate, Model, RelmApp, Sender, WidgetPlus, Widgets};

#[derive(Default)]
struct AppModel {
    counter: u8,
}

enum AppMsg {
    Increment,
    Decrement,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        gtk::ApplicationWindow {
            set_title: Some(&quot;Simple app&quot;),
            set_default_width: 300,
            set_default_height: 100,
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,

                append = &amp;gtk::Button {
                    set_label: &quot;Increment&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Increment);
                    },
                },
                append = &amp;gtk::Button::with_label(&quot;Decrement&quot;) {
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Decrement);
                    },
                },
                append = &amp;gtk::Label {
                    set_margin_all: 5,
                    set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
                }
            },
        }
    }
}

fn main() {
    let model = AppModel::default();
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="efficient-ui-updates"><a class="header" href="#efficient-ui-updates">Efficient UI updates</a></h1>
<p>Relm4 follows the Elm programming model which means that data and widgets are separated. At first glance this might cause a problem. Larger applications need to efficiently update their widgets because rebuilding the whole UI for every update is not an option. But since data and widgets are separated, how do we know which UI elements need to be updated?</p>
<p>Let's have a look at an imaginary example to visualize this problem. Imagine you have an app with 1000 counters and you only increment the first counter. The model receives the increment message for the first counter and increments it. Now the view function gets the updated model with 1000 counters and... well, has no idea what changed! So instead of one UI update we need to do 1000 because we don't know which of our counters was modified.</p>
<p>There are two concepts in Relm4 to avoid unnecessary UI updates</p>
<ul>
<li>Trackers: keep track of which struct fields were modified and only update the UI if they were modified.</li>
<li>Factories: store data in a special data structures similar to the data structures in <a href="https://doc.rust-lang.org/std/collections/index.html"><code>std::collections</code></a> that will keep track of changes and will only apply minimal UI updates.</li>
</ul>
<p>Both concepts are explained in the following chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracker"><a class="header" href="#tracker">Tracker</a></h1>
<p>A tracker in this context just means a data type that's able to track changes to itself. For example, if we increment the counter of the model we used for our first app, the model could tell us later that the counter changed during the last update function.</p>
<p>Relm4 does not promote any implementation of a tracker. You're free to use any implementation you like, you can even implement a tracker yourself. In this example however, we'll use the tracker crate that provides a simple macro that implements a tracker for us automatically.</p>
<p>Using this technique, we will implement a small program which displays two randomly picked icons that are controlled by two buttons:</p>
<p><img src="img/screenshots/tracker-dark-1.png" alt="App screenshot" /></p>
<p>When pressing a button, the icon above it will change. The background of the application will become green when the two icons are identical:</p>
<p><img src="img/screenshots/tracker-dark-2.png" alt="App screenshot with with equal icons" /></p>
<h2 id="the-tracker-crate"><a class="header" href="#the-tracker-crate">The tracker crate</a></h2>
<p>The <code>tracker::track</code> macro implements the following methods for your struct fields:</p>
<ul>
<li>
<p><code>get_#field_name()</code><br />
Get an immutable reference to your field.</p>
</li>
<li>
<p><code>get_mut_#field_name()</code><br />
Get a mutable reference to your field. Assumes the field will be modified and marks it as changed.</p>
</li>
<li>
<p><code>set_#field_name(value)</code><br />
Get a mutable reference to your field. Marks the field as changed only if the new value isn't equal with the previous value.</p>
</li>
<li>
<p><code>update_#field_name(fn)</code><br />
Update your mutable field with a function or a closure. Assumes the field will be modified and marks it as changed.</p>
</li>
</ul>
<p>To check for changes you can call <code>var_name.changed(StructName::field_name())</code> and it will return a bool indication whether the field was updated.</p>
<p>To reset all previous changes, you can call <code>var_name.reset()</code>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>First we have to add the tracker library to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">tracker = &quot;0.1&quot;
</code></pre>
<p>Now let's have a look at a small example.</p>
<pre><code class="language-rust no_run noplayground">#[tracker::track]
struct Test {
    x: u8,
    y: u64,
}

fn main() {
    let mut t = Test {
        x: 0,
        y: 0,
        // the macro generates a new variable called
        // &quot;tracker&quot; that stores the changes
        tracker: 0,
    };

    t.set_x(42);
    // let's check whether the change was detected
    assert!(t.changed(Test::x()));

    // reset t so we don't track old changes
    t.reset();

    t.set_x(42);
    // same value, so no change
    assert!(!t.changed(Test::x()));
}
</code></pre>
<blockquote>
<p>More information about the tracker crate can be found <a href="https://github.com/AaronErhardt/Tracker">here</a>.</p>
</blockquote>
<p>So in short, the <code>tracker::track</code> macro provides different getters and setters that will mark struct fields as changed. You also get a method that checks for changes and a method to reset the changes.</p>
<h1 id="using-trackers-in-relm4-apps"><a class="header" href="#using-trackers-in-relm4-apps">Using trackers in Relm4 apps</a></h1>
<p>Let's build a simple app that shows two random icons and allows the user to set each of them to a new random icon. As a bonus, we want to show a fancy background color if both icons are the same.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/tracker.rs">here</a>. Run <code>cargo run --example tracker</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-icons"><a class="header" href="#the-icons">The icons</a></h2>
<p>Before we can select random icons, we need to quickly implement a function that will return us random image names that are available in the default GTK icon theme.</p>
<pre><code class="language-rust no_run noplayground">const ICON_LIST: &amp;[&amp;str] = &amp;[
    &quot;bookmark-new-symbolic&quot;,
    &quot;edit-copy-symbolic&quot;,
    &quot;edit-cut-symbolic&quot;,
    &quot;edit-find-symbolic&quot;,
    &quot;starred-symbolic&quot;,
    &quot;system-run-symbolic&quot;,
    &quot;emoji-objects-symbolic&quot;,
    &quot;emoji-nature-symbolic&quot;,
    &quot;display-brightness-symbolic&quot;,
];

fn random_icon_name() -&gt; &amp;'static str {
    ICON_LIST
        .iter()
        .choose(&amp;mut rand::thread_rng())
        .expect(&quot;Could not choose a random icon&quot;)
}
</code></pre>
<h2 id="the-model-1"><a class="header" href="#the-model-1">The model</a></h2>
<p>For our model we only need to store the two icon names and whether both of them are identical.</p>
<pre><code class="language-rust no_run noplayground">#[tracker::track]
struct AppModel {
    first_icon: &amp;'static str,
    second_icon: &amp;'static str,
    identical: bool,
}
</code></pre>
<p>The message type is also pretty simple: we just want to update one of the icons.</p>
<pre><code class="language-rust no_run noplayground">enum AppMsg {
    UpdateFirst,
    UpdateSecond,
}
</code></pre>
<p>There are a few notable things for the <code>AppUpdate</code> implementation.
First, we call <code>self.reset()</code> at the top of the update function body. This ensures that the tracker will be reset so we don't track old changes.</p>
<p>Also, we use setters instead of assignments because we want to track these changes. Yet, you could still use the assignment operator if you want to apply changes without notifying the tracker.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        // reset tracker value of the model
        self.reset();

        match msg {
            AppMsg::UpdateFirst =&gt; {
                self.set_first_icon(random_icon_name());
            }
            AppMsg::UpdateSecond =&gt; {
                self.set_second_icon(random_icon_name());
            }
        }
        self.set_identical(self.first_icon == self.second_icon);

        true
    }
}
</code></pre>
<h2 id="the-widgets-1"><a class="header" href="#the-widgets-1">The widgets</a></h2>
<p>Now we reached the interesting part of the code where we can actually make use of the tracker. Let's have a look at the complete widget macro:</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_class_active: track!(model.changed(AppModel::identical()),
                &quot;identical&quot;, model.identical),
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 10,
                set_margin_all: 10,
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    append = &amp;gtk::Image {
                        set_pixel_size: 50,
                        set_icon_name: track!(model.changed(AppModel::first_icon()),
                            Some(model.first_icon)),
                    },
                    append = &amp;gtk::Button {
                        set_label: &quot;New random image&quot;,
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::UpdateFirst);
                        }
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    append = &amp;gtk::Image {
                        set_pixel_size: 50,
                        set_icon_name: track!(model.changed(AppModel::second_icon()),
                            Some(model.second_icon)),
                    },
                    append = &amp;gtk::Button {
                        set_label: &quot;New random image&quot;,
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::UpdateSecond);
                        }
                    }
                },
            }
        }
    }

    fn post_init() {
        relm4::set_global_css(b&quot;.identical { background: #00ad5c; }&quot;);
    }
}
</code></pre>
<p>The overall UI is pretty simple: A window that contains a box. This box has two boxes itself for showing the two icons and the two buttons to update those icons.</p>
<p>There's also something new. With the <code>pre_init()</code> and <code>post_init()</code> functions you can add custom code that will be run either before or after the code the widget macro generates for initialization. In our case, we want to add <a href="https://docs.gtk.org/gtk4/css-properties.html">custom CSS</a> that sets the background color for elements with class name &quot;identical&quot;.</p>
<pre><code class="language-rust no_run noplayground">    fn post_init() {
        relm4::set_global_css(b&quot;.identical { background: #00ad5c; }&quot;);
    }
</code></pre>
<h3 id="the-track-macro"><a class="header" href="#the-track-macro">The track! macro</a></h3>
<p>The <code>track!</code> macro is a simple macro that can be used inside the widget macro and allows us to pass a condition for updates and then the arguments. So the syntax looks like this:</p>
<pre><code class="language-rust no_run noplayground">track!(bool_expression, argument, [further arguments])
</code></pre>
<p>Let's have a look at its first appearance:</p>
<pre><code class="language-rust no_run noplayground">            set_class_active: track!(model.changed(AppModel::identical()),
                &quot;identical&quot;, model.identical),
</code></pre>
<p>The <a href="https://aaronerhardt.github.io/docs/relm4/relm4/util/widget_plus/trait.WidgetPlus.html#tymethod.set_class_active"><code>set_class_active</code></a> method is used to either activate or disable a CSS class. It takes two parameters, the first is the class itself and the second is a boolean which specifies if the class should be added (<code>true</code>) or removed (<code>false</code>).</p>
<p>The first parameter of the <code>track!</code> macro will be used as a condition to check whether something has changed. If this condition is <code>true</code>, the <code>set_class_active</code> method will be called with all the parameters of the <code>track!</code> macro that follow the condition.</p>
<p>The macro expansion for the <code>track!</code> macro in the generated view function looks roughly like this:</p>
<pre><code class="language-rust no_run noplayground">if model.changed(AppModel::identical()) {
    self.main_window.set_class_active(&quot;identical&quot;, model.identical);
}
</code></pre>
<p>That's all. It's pretty simple, actually. We just use a condition that allows us to update our widgets only when needed.</p>
<p>The second <code>track!</code> macro looks very similar but only passes one argument:</p>
<pre><code class="language-rust no_run noplayground">                        set_icon_name: track!(model.changed(AppModel::first_icon()),
                            Some(model.first_icon)),
</code></pre>
<blockquote>
<p>Since the <code>track!</code> macro parses expressions, you can use the following syntax to debug your trackers:</p>
<p><code>track!(bool_expression, { println!(&quot;Update widget&quot;); argument })</code></p>
</blockquote>
<h2 id="the-main-function"><a class="header" href="#the-main-function">The main function</a></h2>
<p>There's one last thing to point out. When initializing our model, we need to initialize the <code>tracker</code> field as well. The initial value doesn't really matter because we call <code>reset()</code> in the update function anyway, but usually <code>0</code> is used.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let model = AppModel {
        first_icon: random_icon_name(),
        second_icon: random_icon_name(),
        identical: false,
        tracker: 0,
    };
    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>
<h2 id="the-complete-code-2"><a class="header" href="#the-complete-code-2">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use rand::prelude::IteratorRandom;
use relm4::{send, AppUpdate, Model, RelmApp, Sender, WidgetPlus, Widgets};

const ICON_LIST: &amp;[&amp;str] = &amp;[
    &quot;bookmark-new-symbolic&quot;,
    &quot;edit-copy-symbolic&quot;,
    &quot;edit-cut-symbolic&quot;,
    &quot;edit-find-symbolic&quot;,
    &quot;starred-symbolic&quot;,
    &quot;system-run-symbolic&quot;,
    &quot;emoji-objects-symbolic&quot;,
    &quot;emoji-nature-symbolic&quot;,
    &quot;display-brightness-symbolic&quot;,
];

fn random_icon_name() -&gt; &amp;'static str {
    ICON_LIST
        .iter()
        .choose(&amp;mut rand::thread_rng())
        .expect(&quot;Could not choose a random icon&quot;)
}

enum AppMsg {
    UpdateFirst,
    UpdateSecond,
}

// The track proc macro allows to easily track changes to different
// fields of the model
#[tracker::track]
struct AppModel {
    first_icon: &amp;'static str,
    second_icon: &amp;'static str,
    identical: bool,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        // reset tracker value of the model
        self.reset();

        match msg {
            AppMsg::UpdateFirst =&gt; {
                self.set_first_icon(random_icon_name());
            }
            AppMsg::UpdateSecond =&gt; {
                self.set_second_icon(random_icon_name());
            }
        }
        self.set_identical(self.first_icon == self.second_icon);

        true
    }
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_class_active: track!(model.changed(AppModel::identical()),
                &quot;identical&quot;, model.identical),
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 10,
                set_margin_all: 10,
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    append = &amp;gtk::Image {
                        set_pixel_size: 50,
                        set_icon_name: track!(model.changed(AppModel::first_icon()),
                            Some(model.first_icon)),
                    },
                    append = &amp;gtk::Button {
                        set_label: &quot;New random image&quot;,
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::UpdateFirst);
                        }
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 10,
                    append = &amp;gtk::Image {
                        set_pixel_size: 50,
                        set_icon_name: track!(model.changed(AppModel::second_icon()),
                            Some(model.second_icon)),
                    },
                    append = &amp;gtk::Button {
                        set_label: &quot;New random image&quot;,
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::UpdateSecond);
                        }
                    }
                },
            }
        }
    }

    fn post_init() {
        relm4::set_global_css(b&quot;.identical { background: #00ad5c; }&quot;);
    }
}

fn main() {
    let model = AppModel {
        first_icon: random_icon_name(),
        second_icon: random_icon_name(),
        identical: false,
        tracker: 0,
    };
    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory"><a class="header" href="#factory">Factory</a></h1>
<p>Factories are used to generate widgets from collections of data. 
If you modify the collection of data, the widgets are generated and updated automatically.
Also, they make it simple to modify the data from the UI.</p>
<blockquote>
<p>GTK has factories, too, yet under the hood they are quite different from Relm4's factories. 
In most cases, Relm4's factories will be the easier solution but if you need more control, you can always use <a href="https://gtk-rs.org/gtk4-rs/git/book/todo_app_1.html">GTK's factories with gtk4-rs</a>.</p>
</blockquote>
<p>The app we will build now will look like this:</p>
<p><img src="img/screenshots/factory-dark.png" alt="App screenshot dark" /></p>
<p>It will have a dynamic number of counters which can be changed by pressing the add or remove buttons.
Clicking on a counter will decrement it.</p>
<h2 id="factories-in-relm4"><a class="header" href="#factories-in-relm4">Factories in Relm4</a></h2>
<p>Let's have a look at factories in Relm4. We want to write this simple application where one can create and remove many counters. Each counter needs to store its value and display widgets to allow modifying the counter. In this example we will only decrement the counter.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/factory.rs">here</a>. Run <code>cargo run --example factory</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h3 id="the-model-2"><a class="header" href="#the-model-2">The model</a></h3>
<p>The most common solution for storing collections of data is a <code>Vec</code>. Yet a <code>Vec</code> can't help us with efficient UI updates because it does not track changes to itself. If we used a <code>Vec</code> we'd have to assume everything could have changed and create all widgets over and over again. So instead we use a <code>FactoryVec</code> to store our data. A <code>FactoryVec</code> is a simple data structure provided by Relm4 that allows us to push, pop and modify elements. Additionally, it automatically keeps track of all the changes made to itself.</p>
<blockquote>
<p>An overview over all available factory data structures can be found in the documentation <a href="https://aaronerhardt.github.io/docs/relm4/relm4/factory/collections/index.html">here</a>.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVec&lt;Counter&gt;,
    created_counters: u8,
}
</code></pre>
<p>As you can see, we first define the struct <code>Counter</code> that just stores the value of a single counter. Then we use a <code>FactoryVec</code> to store our counters in the model. For now, all of this is just data. Similar to the model type, we need to define the data structures we need for our UI first. Then we will define how to create widgets from this data. Yet unlike the model type, we can have many counters in a <code>FactoryVec</code> and each of them will be represented by its own widgets.</p>
<p>To give our counters an unique value at initialization, we also add a separate counter to the model to count the amount of counters we did already create. </p>
<h2 id="the-message-type"><a class="header" href="#the-message-type">The message type</a></h2>
<p>The actions we want to perform are</p>
<ul>
<li>Add new counters</li>
<li>Remove counters</li>
<li>Decrement a counter</li>
</ul>
<p>Accordingly, our message type looks like this:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMsg {
    Add,
    Remove,
    Clicked(usize),
}
</code></pre>
<p>You'll notice that an index is passed with <code>AppMsg::Clicked</code>. This allows us to select the counter that emitted the clicked signal.</p>
<h2 id="the-update-function"><a class="header" href="#the-update-function">The update function</a></h2>
<p>The update function takes care of adding, removing and decrementing counters. Each new counter will be initialized with the amount of counters created before it.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Add =&gt; {
                self.counters.push(Counter {
                    value: self.created_counters,
                });
                self.created_counters += 1;
            }
            AppMsg::Remove =&gt; {
                self.counters.pop();
            }
            AppMsg::Clicked(index) =&gt; {
                if let Some(counter) = self.counters.get_mut(index) {
                    counter.value = counter.value.wrapping_sub(1);
                }
            }
        }
        true
    }
}
</code></pre>
<blockquote>
<p>The <code>get</code> and <code>get_mut</code> methods inside <code>FactoryVec</code> return <code>Some</code> if the element exists and <code>None</code> if the index is invalid. It's recommended to not unwrap this <code>Option</code> because messages (and also the indices sent with them) are queued up if your update and view functions are slow and can be stale by the time they are handled.</p>
</blockquote>
<h2 id="the-factory-implementation"><a class="header" href="#the-factory-implementation">The factory implementation</a></h2>
<p>So far the code looked pretty normal. Now to the interesting part of the code.</p>
<p>The first thing we need to implement for a factory is a widgets type. That sounds familiar, right? The widgets used for the factory are actually very similar to the widgets used for your application. They define which widgets represent an element inside a factory data structure like <code>FactoryVec</code>.</p>
<p>In our case, we just need a simple button that will decrement the counter when clicked and will also display the counter value.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct FactoryWidgets {
    button: gtk::Button,
}
</code></pre>
<p>The <code>FactoryPrototype</code> trait we need next is very similar to the <code>Widgets</code> trait, too: it defines how widgets are created and updated. Let's have a look at the implementation:</p>
<pre><code class="language-rust no_run noplayground">impl FactoryPrototype for Counter {
    type Factory = FactoryVec&lt;Self&gt;;
    type Widgets = FactoryWidgets;
    type Root = gtk::Button;
    type View = gtk::Box;
    type Msg = AppMsg;
</code></pre>
<p>Alright, there are quite a few types! Let's look at them one by one:</p>
<ul>
<li><strong>Factory:</strong> the data structure we use to store our elements. In our case, a <code>FactoryVec</code>.</li>
<li><strong>Widgets:</strong> the struct that stores out widgets. That's the <code>FactoryWidgets</code> type we just created.</li>
<li><strong>Root:</strong> similar to the root in the <code>Widgets</code> trait, it represents the outermost widget. This is usually a container like <code>gtk::Box</code> but in our case we just have a <code>gtk::Button</code>.</li>
<li><strong>View:</strong> the container we want our widgets to be placed inside. The simplest solution for this is a <code>gtk::Box</code>.</li>
<li><strong>Msg:</strong> the messages we want to send to the model containing this factory.</li>
</ul>
<h3 id="the-generate-function"><a class="header" href="#the-generate-function">The generate function</a></h3>
<p>The generate function is similar to <code>init_view</code> in the <code>Widgets</code> trait: it generates the widgets from data. You'll notice that there's an index as well that we can use to send messages that index the data these widgets represent. The index type might vary between different factory data structures. For the factory type <code>FactoryVec</code> an index of the type <code>usize</code> is being used.</p>
<pre><code class="language-rust no_run noplayground">    fn generate(&amp;self, index: &amp;usize, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let button = gtk::Button::with_label(&amp;self.value.to_string());
        let index = *index;
        button.connect_clicked(move |_| {
            sender.send(AppMsg::Clicked(index)).unwrap();
        });

        FactoryWidgets { button }
    }
</code></pre>
<p>As you can see, we send a message with the index back to the update function to decrement this specific counter when the button is pressed.</p>
<h3 id="the-position-function"><a class="header" href="#the-position-function">The position function</a></h3>
<p>In our case, the function is pretty short:</p>
<pre><code class="language-rust no_run noplayground">    fn position(&amp;self, _index: &amp;usize) {}
</code></pre>
<p>The <code>gtk::Box</code> we use here is one-dimensional. This means that a <code>FactoryVec</code> can perfectly resemble the layout with its own internal structure because it's one-dimenational as well. In other words, the first element of the <code>FactoryVec</code> is also the first in the <code>gtk::Box</code>. Yet, some container widgets such as <code>gtk::Grid</code> place widgets at fixed two-dimensional positions and rely in the position function to know where a new widget should be added.</p>
<p>Because we don't use it here, the position function is explained in the next chapter.</p>
<h3 id="the-update-function-1"><a class="header" href="#the-update-function-1">The update function</a></h3>
<p>The update function is similar to <code>view</code> in the <code>Widgets</code> trait: it updates the widgets according to the updated data.</p>
<pre><code class="language-rust no_run noplayground">    fn update(&amp;self, _index: &amp;usize, widgets: &amp;FactoryWidgets) {
        widgets.button.set_label(&amp;self.value.to_string());
    }
</code></pre>
<p>We just update the label of the button to represent the updated counter value.</p>
<h3 id="the-get_root-function"><a class="header" href="#the-get_root-function">The get_root function</a></h3>
<p>The last function we need is the <code>get_root</code> function. It's similar to the <code>root_widget</code> in the <code>Widgets</code> trait: it returns the root widget, the outermost of our widgets.</p>
<pre><code class="language-rust no_run noplayground">    fn get_root(widgets: &amp;FactoryWidgets) -&gt; &amp;gtk::Button {
        &amp;widgets.button
    }
</code></pre>
<h2 id="the-widgets-2"><a class="header" href="#the-widgets-2">The widgets</a></h2>
<p>The last piece to make our code complete it the definition of the widgets for the application. There's mostly one notable thing: the <code>factory!</code> macro.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        gtk::ApplicationWindow {
            set_default_width: 300,
            set_default_height: 200,
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,
                append = &amp;gtk::Button {
                    set_label: &quot;Add&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Add);
                    }
                },
                append = &amp;gtk::Button {
                    set_label: &quot;Remove&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Remove);
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_margin_all: 5,
                    set_spacing: 5,
                    factory!(model.counters),
                }
            }
        }
    }
}
</code></pre>
<p>The <code>factory!</code> macro that's almost at the end of the widgets definition now updates our widgets according to the changes we make to the data in our model. It sits inside of the <code>gtk::Box</code> we want to use as a container for our counter.</p>
<blockquote>
<p>The <code>factory!</code> macro simply expands to <code>model.data.generate(&amp;self.gen_box, sender)</code> where <code>gen_box</code> is the <code>gtk::Box</code> we used as a container. The <code>generate</code> function is provided by the <code>Factory</code> trait that's implemented for <code>FactoryVec</code> and similar data structures.</p>
</blockquote>
<p>Now to test this, we could add a print statement to the update function. It will show that decrementing one counter will only update the widgets of one counter. Great, that's exactly what we wanted!</p>
<h2 id="the-complete-code-3"><a class="header" href="#the-complete-code-3">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::glib::Sender;
use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::factory::{FactoryPrototype, FactoryVec};
use relm4::{send, AppUpdate, Model, RelmApp, WidgetPlus, Widgets};

#[derive(Debug)]
enum AppMsg {
    Add,
    Remove,
    Clicked(usize),
}

struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVec&lt;Counter&gt;,
    created_counters: u8,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Add =&gt; {
                self.counters.push(Counter {
                    value: self.created_counters,
                });
                self.created_counters += 1;
            }
            AppMsg::Remove =&gt; {
                self.counters.pop();
            }
            AppMsg::Clicked(index) =&gt; {
                if let Some(counter) = self.counters.get_mut(index) {
                    counter.value = counter.value.wrapping_sub(1);
                }
            }
        }
        true
    }
}

#[derive(Debug)]
struct FactoryWidgets {
    button: gtk::Button,
}

impl FactoryPrototype for Counter {
    type Factory = FactoryVec&lt;Self&gt;;
    type Widgets = FactoryWidgets;
    type Root = gtk::Button;
    type View = gtk::Box;
    type Msg = AppMsg;

    fn generate(&amp;self, index: &amp;usize, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let button = gtk::Button::with_label(&amp;self.value.to_string());
        let index = *index;
        button.connect_clicked(move |_| {
            sender.send(AppMsg::Clicked(index)).unwrap();
        });

        FactoryWidgets { button }
    }

    fn position(&amp;self, _index: &amp;usize) {}

    fn update(&amp;self, _index: &amp;usize, widgets: &amp;FactoryWidgets) {
        widgets.button.set_label(&amp;self.value.to_string());
    }

    fn get_root(widgets: &amp;FactoryWidgets) -&gt; &amp;gtk::Button {
        &amp;widgets.button
    }
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        gtk::ApplicationWindow {
            set_default_width: 300,
            set_default_height: 200,
            set_child = Some(&amp;gtk::Box) {
                set_orientation: gtk::Orientation::Vertical,
                set_margin_all: 5,
                set_spacing: 5,
                append = &amp;gtk::Button {
                    set_label: &quot;Add&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Add);
                    }
                },
                append = &amp;gtk::Button {
                    set_label: &quot;Remove&quot;,
                    connect_clicked(sender) =&gt; move |_| {
                        send!(sender, AppMsg::Remove);
                    }
                },
                append = &amp;gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_margin_all: 5,
                    set_spacing: 5,
                    factory!(model.counters),
                }
            }
        }
    }
}

fn main() {
    let model = AppModel {
        counters: FactoryVec::new(),
        created_counters: 0,
    };

    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-position-function-1"><a class="header" href="#the-position-function-1">The position function</a></h1>
<p>Most widgets such as <code>gtk::Box</code> don't use the position function because they are one-dimensional and place widgets relative to each other. However, a few widgets such as <code>gtk::Grid</code> use fixed positions and need the position function to work inside a factory.</p>
<p>The task of the position function is mainly to map the index to a specific position/area (x, y, width and height) of a factory widget inside the parent widget (view).</p>
<blockquote>
<p>The code we will use in this chapter is based on the grid_factory example <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/grid_factory.rs">here</a>. Run <code>cargo run --example grid_factory</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>Let's take a grid as an example. For a grid, there are many possibilities to place your widgets. You can, for example, place three, four or five widgets per row or you could place a certain amount of widgets per column. You can even create patterns like a chess grid if you want to.</p>
<p>However, we want to use a factory for generating our widgets, which means we only have the index to calculate the desired two-dimensional position. In the simplest case, we create a layout that places a certain amount of widgets per row or per column.</p>
<p><img src="img/grid_layout.svg" alt="Grid layout example" /></p>
<p>To place 3 elements per row from left to right in a <code>gtk::Grid</code> we could use the following position function.</p>
<pre><code class="language-rust no_run noplayground">    fn position(&amp;self, index: &amp;usize) -&gt; GridPosition {
        let index = *index as i32;

        let row = index / 3;
        let column = index % 3;

        GridPosition {
            column,
            row,
            width: 1,
            height: 1,
        }
    }
</code></pre>
<p>And indeed, it works as expected.</p>
<p><img src="img/row_grid_screenshot.png" alt="Row placement grid screenshot" /></p>
<h2 id="a-chess-grid"><a class="header" href="#a-chess-grid">A chess grid</a></h2>
<p>Let's have a look at a more complex layout. It's unlikely that this would be used in a real application, but it's still interesting to have a look at it.</p>
<p>To create a chess grid layout, we need to place our widgets only on fields of one color and leave the other fields empty. Or in other words, we only place widgets on the fields a bishop can reach.</p>
<p><img src="img/chess_layout.svg" alt="Grid layout example" /></p>
<p>Actually, the code isn't too complicated.</p>
<pre><code class="language-rust no_run noplayground">    fn position(&amp;self, index: &amp;usize) -&gt; GridPosition {
        let index = *index as i32;

        // add a new row for every 5 elements
        let row = index / 5;
        // use every second column and move columns in uneven rows by 1
        let column = (index % 5) * 2 + row % 2;

        GridPosition {
            column,
            row,
            width: 1,
            height: 1,
        }
    }
</code></pre>
<p>And as you can see, it works!</p>
<p><img src="img/chess_grid_screenshot.png" alt="Chess grid layout screenshot" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-factories"><a class="header" href="#advanced-factories">Advanced factories</a></h1>
<p>In this chapter we will build an even more advanced UI for modifying the available counters:</p>
<p><img src="img/screenshots/factory-advanced-dark.png" alt="App screenshot dark" /></p>
<p>Additionally, certain counters can now be removed or inserted above or below an existing counter.</p>
<blockquote>
<p>If you're not familiar with the <code>Rc</code> type of the standard library, have a look at <a href="https://doc.rust-lang.org/std/rc/index.html">this</a>.</p>
</blockquote>
<p>The <code>FactoryVec</code> we used in the previous chapter is sufficient for simple applications where elements only need to be added and removed from the back. Yet a common use case would be to add elements before another one or to remove a specific element. That introduces additional complexity that needs to be taken care of but fortunately this is mostly handled by Relm4.</p>
<p>To show this, we'll create a similar counter app to the one of the previous chapter, but this time on <strong>steroids</strong>: we'll add functionality to add counters before and after a specific counter and to remove a certain counter. To get the required flexibility, we'll use the <code>FactoryVecDeque</code> type instead of a <code>FactoryVec</code>.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/factory_advanced.rs">here</a>. Run <code>cargo run --example factory_advanced</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="indices"><a class="header" href="#indices">Indices</a></h2>
<p>The indices of a <code>FactoryVec</code> were just numbers of type <code>usize</code>. That's great unless elements can move and change their index. This tragedy starts when we, for example, add an element to the front: the new element now has index <code>0</code>, the element that had index <code>0</code> before now has index <code>1</code> and so on. Adding one element will shift the indices of all following elements. If we naively create a signal handler similar to the previous chapter were we just copied the index at start and moved it into the closure, we will quickly end up with quite wrong or even out-of-bounds indices as elements are added and removed at arbitrary positions.</p>
<p>One solution would be to recreate all signal handlers with the updated indices once an element's index has been changed. However, that's complicated because you need to remove the old signal handlers first and therefore you have to store all signal handler IDs.</p>
<p>The solution Relm4 chose was dynamic indices. These indices are updated automatically to always point at the same element.</p>
<h3 id="the-message-type-1"><a class="header" href="#the-message-type-1">The message type</a></h3>
<pre><code class="language-rust no_run noplayground">type MsgIndex = Weak&lt;DynamicIndex&gt;;

#[derive(Debug)]
enum AppMsg {
    AddFirst,
    RemoveLast,
    CountAt(MsgIndex),
    RemoveAt(MsgIndex),
    InsertBefore(MsgIndex),
    InsertAfter(MsgIndex),
}
</code></pre>
<p>As you can see, we use a lot of <code>MsgIndex</code> aka <code>Weak&lt;DynamicIndex&gt;</code>. This allows us to always hold a reference to the dynamic index value.</p>
<p>The reason we use weak pointers here is that we donâ€™t want to hold references to invalid indices. We donâ€™t know if our messages are handled immediately or queued up instead, so the data the index was pointing at could have been replaced by a new data in the meantime. Usually this happens so rarely that this can be ignored, but with the weak pointers we guarantee that the indices are not kept alive in the message queue and we will never use a stale index.</p>
<h3 id="the-model-3"><a class="header" href="#the-model-3">The model</a></h3>
<p>The model is very similar to the previous chapter. The only difference is that we use <code>FactoryVecDeque</code> as a data structure now.</p>
<pre><code class="language-rust no_run noplayground">struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVecDeque&lt;Counter&gt;,
    received_messages: u8,
}
</code></pre>
<h3 id="the-update-function-2"><a class="header" href="#the-update-function-2">The update function</a></h3>
<p>The update function now handles quite a lot of events. We want to</p>
<ul>
<li>Add elements at the start</li>
<li>Remove elements from the back</li>
<li>Decrement (count) a counter at a specific index</li>
<li>Insert a new counter before another counter</li>
<li>Insert a new counter after another counter</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::AddFirst =&gt; {
                self.counters.push_front(Counter {
                    value: self.received_messages,
                });
            }
            AppMsg::RemoveLast =&gt; {
                self.counters.pop_back();
            }
            AppMsg::CountAt(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    if let Some(counter) = self.counters.get_mut(index.current_index()) {
                        counter.value = counter.value.wrapping_sub(1);
                    }
                }
            }
            AppMsg::RemoveAt(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.remove(index.current_index());
                }
            }
            AppMsg::InsertBefore(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.insert(
                        index.current_index(),
                        Counter {
                            value: self.received_messages,
                        },
                    );
                }
            }
            AppMsg::InsertAfter(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.insert(
                        index.current_index() + 1,
                        Counter {
                            value: self.received_messages,
                        },
                    );
                }
            }
        }
        self.received_messages += 1;
        true
    }
}
</code></pre>
<p>To get the current index value from the dynamic index, we simply call <code>index.current_index()</code>.</p>
<h2 id="the-factory-implementation-1"><a class="header" href="#the-factory-implementation-1">The factory implementation</a></h2>
<p>The factory implementation is mostly the same, so we'll just have a look at what has changed.</p>
<h3 id="the-widgets-type"><a class="header" href="#the-widgets-type">The widgets type</a></h3>
<p>Because we have four actions per counter now, we also need an additional box to store these buttons.
To be able to provide the root widget via the <code>get_root</code> function we need to store the box in the widgets type.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
struct FactoryWidgets {
    hbox: gtk::Box,
    counter_button: gtk::Button,
}
</code></pre>
<h3 id="the-generate-function-1"><a class="header" href="#the-generate-function-1">The generate function</a></h3>
<p>For the generate function, we need to first generate the new buttons and the box.</p>
<pre><code class="language-rust no_run noplayground">    fn generate(&amp;self, index: &amp;Rc&lt;DynamicIndex&gt;, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let hbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Horizontal)
            .spacing(5)
            .build();

        let counter_button = gtk::Button::with_label(&amp;self.value.to_string());
        let index: Rc&lt;DynamicIndex&gt; = index.clone();

        let remove_button = gtk::Button::with_label(&quot;Remove&quot;);
        let ins_above_button = gtk::Button::with_label(&quot;Add above&quot;);
        let ins_below_button = gtk::Button::with_label(&quot;Add below&quot;);
</code></pre>
<p>Then we need to place the buttons inside of the box.</p>
<pre><code class="language-rust no_run noplayground">        hbox.append(&amp;counter_button);
        hbox.append(&amp;remove_button);
        hbox.append(&amp;ins_above_button);
        hbox.append(&amp;ins_below_button);
</code></pre>
<p>Now we can connect the messages. We always send a weak pointer of our dynamic index.</p>
<pre><code class="language-rust no_run noplayground">        {
            let sender = sender.clone();
            let index = index.clone();
            counter_button.connect_clicked(move |_| {
                send!(sender, AppMsg::CountAt(Rc::downgrade(&amp;index)));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            remove_button.connect_clicked(move |_| {
                send!(sender, AppMsg::RemoveAt(Rc::downgrade(&amp;index)));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            ins_above_button.connect_clicked(move |_| {
                send!(sender, AppMsg::InsertBefore(Rc::downgrade(&amp;index)));
            });
        }

        ins_below_button.connect_clicked(move |_| {
            send!(sender, AppMsg::InsertAfter(Rc::downgrade(&amp;index)));
        });

        FactoryWidgets {
            hbox,
            counter_button,
        }
</code></pre>
<p>And that's it! All the other complex operations that keep track of changes are implemented in Relm4 already, we just need to use dynamic indices to make our program work :)</p>
<h2 id="the-complete-code-4"><a class="header" href="#the-complete-code-4">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<blockquote>
<p>Unlike the example in the previous chapter, the following code does not use the widget macro from relm4-macros but implements the <code>Widgets</code> trait manually. Yet, the generated code from the macro and the manual code should be almost identical.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">use gtk::glib::Sender;
use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt};
use relm4::factory::{DynamicIndex, Factory, FactoryPrototype, FactoryVecDeque};
use relm4::*;

use std::rc::{Rc, Weak};

type MsgIndex = Weak&lt;DynamicIndex&gt;;

#[derive(Debug)]
enum AppMsg {
    AddFirst,
    RemoveLast,
    CountAt(MsgIndex),
    RemoveAt(MsgIndex),
    InsertBefore(MsgIndex),
    InsertAfter(MsgIndex),
}

struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVecDeque&lt;Counter&gt;,
    received_messages: u8,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::AddFirst =&gt; {
                self.counters.push_front(Counter {
                    value: self.received_messages,
                });
            }
            AppMsg::RemoveLast =&gt; {
                self.counters.pop_back();
            }
            AppMsg::CountAt(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    if let Some(counter) = self.counters.get_mut(index.current_index()) {
                        counter.value = counter.value.wrapping_sub(1);
                    }
                }
            }
            AppMsg::RemoveAt(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.remove(index.current_index());
                }
            }
            AppMsg::InsertBefore(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.insert(
                        index.current_index(),
                        Counter {
                            value: self.received_messages,
                        },
                    );
                }
            }
            AppMsg::InsertAfter(weak_index) =&gt; {
                if let Some(index) = weak_index.upgrade() {
                    self.counters.insert(
                        index.current_index() + 1,
                        Counter {
                            value: self.received_messages,
                        },
                    );
                }
            }
        }
        self.received_messages += 1;
        true
    }
}

#[derive(Debug)]
struct FactoryWidgets {
    hbox: gtk::Box,
    counter_button: gtk::Button,
}

impl FactoryPrototype for Counter {
    type Factory = FactoryVecDeque&lt;Self&gt;;
    type Widgets = FactoryWidgets;
    type Root = gtk::Box;
    type View = gtk::Box;
    type Msg = AppMsg;

    fn generate(&amp;self, index: &amp;Rc&lt;DynamicIndex&gt;, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let hbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Horizontal)
            .spacing(5)
            .build();

        let counter_button = gtk::Button::with_label(&amp;self.value.to_string());
        let index: Rc&lt;DynamicIndex&gt; = index.clone();

        let remove_button = gtk::Button::with_label(&quot;Remove&quot;);
        let ins_above_button = gtk::Button::with_label(&quot;Add above&quot;);
        let ins_below_button = gtk::Button::with_label(&quot;Add below&quot;);

        hbox.append(&amp;counter_button);
        hbox.append(&amp;remove_button);
        hbox.append(&amp;ins_above_button);
        hbox.append(&amp;ins_below_button);

        {
            let sender = sender.clone();
            let index = index.clone();
            counter_button.connect_clicked(move |_| {
                send!(sender, AppMsg::CountAt(Rc::downgrade(&amp;index)));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            remove_button.connect_clicked(move |_| {
                send!(sender, AppMsg::RemoveAt(Rc::downgrade(&amp;index)));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            ins_above_button.connect_clicked(move |_| {
                send!(sender, AppMsg::InsertBefore(Rc::downgrade(&amp;index)));
            });
        }

        ins_below_button.connect_clicked(move |_| {
            send!(sender, AppMsg::InsertAfter(Rc::downgrade(&amp;index)));
        });

        FactoryWidgets {
            hbox,
            counter_button,
        }
    }

    fn position(&amp;self, _index: &amp;Rc&lt;DynamicIndex&gt;) {}

    fn update(&amp;self, _index: &amp;Rc&lt;DynamicIndex&gt;, widgets: &amp;FactoryWidgets) {
        widgets.counter_button.set_label(&amp;self.value.to_string());
    }

    fn get_root(widget: &amp;FactoryWidgets) -&gt; &amp;gtk::Box {
        &amp;widget.hbox
    }
}

struct AppWidgets {
    main: gtk::ApplicationWindow,
    gen_box: gtk::Box,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;

    fn init_view(_model: &amp;AppModel, _components: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let main = gtk::ApplicationWindowBuilder::new()
            .default_width(300)
            .default_height(200)
            .build();
        let main_box = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .margin_end(5)
            .margin_top(5)
            .margin_start(5)
            .margin_bottom(5)
            .spacing(5)
            .build();

        let gen_box = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .margin_end(5)
            .margin_top(5)
            .margin_start(5)
            .margin_bottom(5)
            .spacing(5)
            .build();

        let add = gtk::Button::with_label(&quot;Add&quot;);
        let remove = gtk::Button::with_label(&quot;Remove&quot;);

        main_box.append(&amp;add);
        main_box.append(&amp;remove);
        main_box.append(&amp;gen_box);

        main.set_child(Some(&amp;main_box));

        let cloned_sender = sender.clone();
        add.connect_clicked(move |_| {
            cloned_sender.send(AppMsg::AddFirst).unwrap();
        });

        remove.connect_clicked(move |_| {
            sender.send(AppMsg::RemoveLast).unwrap();
        });

        AppWidgets { main, gen_box }
    }

    fn view(&amp;mut self, model: &amp;AppModel, sender: Sender&lt;AppMsg&gt;) {
        model.counters.generate(&amp;self.gen_box, sender);
    }

    fn root_widget(&amp;self) -&gt; gtk::ApplicationWindow {
        self.main.clone()
    }
}

fn main() {
    let model = AppModel {
        counters: FactoryVecDeque::new(),
        received_messages: 0,
    };

    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<p>I've already mentioned components several times in the previous chapters. Now we'll finally have a look at them.</p>
<p>In short, components are independent parts of your application that can communicate with each other through messages. They are used in a parent-child model: The main app can have components and each component can have child components that again can have child components. This means that each component has a parent, whereas the main app is at the top of this tree structure and therefore does not have a parent. Also, each component can send and receive messages from both parent and children.</p>
<p>To showcase this, we will create a small application which opens a dialog when it gets closed. The headerbar and the dialog will be implemented as standalone components. The communication to the main application will be done via messages.</p>
<p><img src="img/screenshots/components-dark-1.png" alt="App screenshot dark" /></p>
<p><img src="img/screenshots/components-dark-2.png" alt="App screenshot dark" /></p>
<h2 id="when-to-use-components"><a class="header" href="#when-to-use-components">When to use components</a></h2>
<p>Components are mainly useful for separating parts of the UI into smaller, more manageable parts. They are not necessary but for larger applications, they can be very helpful.</p>
<h1 id="example-application"><a class="header" href="#example-application">Example application</a></h1>
<p>Let's write a small example app to see how components can be used in action. For this example, we write parts of an app that can edit images.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/components.rs">here</a>. Run <code>cargo run --example components</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-header-bar"><a class="header" href="#the-header-bar">The header bar</a></h2>
<p>Our first component will be a header bar. There are not a lot of advantages for writing this component except for reducing the complexity in other parts of our UI.</p>
<p>The header bar will have three buttons for three modes that our application can have:</p>
<ul>
<li><strong>View:</strong> View the image.</li>
<li><strong>Edit:</strong> Edit the image.</li>
<li><strong>Export:</strong> Export the image in different formats.</li>
</ul>
<p>We will not implement the actual functionality, but use placeholders instead to keep things simple.</p>
<h3 id="the-model-4"><a class="header" href="#the-model-4">The model</a></h3>
<p>Usually you want to store everything that only affects your component in the state of the component. In this case however, there is no state that can be stored in the component, but only a state that affects the root component (app). Therefore, we leave the model empty and only send messages to the root component.</p>
<pre><code class="language-rust no_run noplayground">struct HeaderModel {}
</code></pre>
<p>The message type allows us to switch between the modes.</p>
<pre><code class="language-rust no_run noplayground">enum HeaderMsg {
    View,
    Edit,
    Export,
}
</code></pre>
<p>For components we also need to implement the <code>Model</code> trait. The <code>Components</code> type is empty here because it refers to child components. We don't have any child components for our header bar so we use a <code>()</code>.</p>
<pre><code class="language-rust no_run noplayground">impl Model for HeaderModel {
    type Msg = HeaderMsg;
    type Widgets = HeaderWidgets;
    type Components = ();
}
</code></pre>
<p>The update function is rather minimal. If our header bar were more complex, storing state in this component would make sense, but because we just handle a few buttons, we can simply forward messages. For that we can use the <code>parent_sender</code>. You can see that the message type of the main application is <code>AppMsg</code> and that there's an enum <code>AppMode</code>. Both were not introduced yet, but will be explained later. For now, we just need to know that this component will send <code>SetMode</code> messages to the app.</p>
<pre><code class="language-rust no_run noplayground">impl ComponentUpdate&lt;AppModel&gt; for HeaderModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        HeaderModel {}
    }

    fn update(
        &amp;mut self,
        msg: HeaderMsg,
        _components: &amp;(),
        _sender: Sender&lt;HeaderMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            HeaderMsg::View =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::View));
            }
            HeaderMsg::Edit =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Edit));
            }
            HeaderMsg::Export =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Export));
            }
        }
    }
}
</code></pre>
<blockquote>
<p>We don't use the <code>_parent_model</code> argument of the <code>init_model</code> in this example. Yet you can use it if you need to access information from the parent model during initialization, for example for passing a resource shared with the component.</p>
</blockquote>
<h3 id="the-widgets-3"><a class="header" href="#the-widgets-3">The widgets</a></h3>
<p>There's nothing special about widgets of a component. The only difference to the main app is that the root widget doesn't need to be a <code>gtk::ApplicationWindow</code>. Instead, we use a <code>gtk::HeaderBar</code> here, but theoretically the root widget doesn't even need to be a widget at all (which can be useful in special cases).</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;HeaderModel, AppModel&gt; for HeaderWidgets {
    view! {
        gtk::HeaderBar {
            set_title_widget = Some(&amp;gtk::Box) {
                add_css_class: &quot;linked&quot;,
                append: group = &amp;gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::View);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Edit);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Export);
                        }
                    },
                },
            }
        }
    }
}
</code></pre>
<h2 id="the-close-alert"><a class="header" href="#the-close-alert">The close alert</a></h2>
<p>Like a normal application that's used to edit files, we want to notify the user before accidentally closing the application and discarding all progress. For this â€” you might have guessed it already â€” we will use another component.</p>
<h3 id="the-model-5"><a class="header" href="#the-model-5">The model</a></h3>
<p>The state of the dialog only needs to store whether or not it's hidden.</p>
<pre><code class="language-rust no_run noplayground">struct DialogModel {
    hidden: bool,
}
</code></pre>
<p>The message contains three options:</p>
<ul>
<li>Show is used by the parent to display the dialog.</li>
<li>Accept is used internally to indicate that the user agreed to close the application.</li>
<li>Cancel is used internally to indicate that the user changes his mind and doesn't want to close the application.</li>
</ul>
<pre><code class="language-rust no_run noplayground">enum DialogMsg {
    Show,
    Accept,
    Cancel,
}
</code></pre>
<p>The update function updates the state of the dialog and sends a close message if the user accepted.</p>
<pre><code class="language-rust no_run noplayground">impl ComponentUpdate&lt;AppModel&gt; for DialogModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        DialogModel { hidden: true }
    }

    fn update(
        &amp;mut self,
        msg: DialogMsg,
        _components: &amp;(),
        _sender: Sender&lt;DialogMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            DialogMsg::Show =&gt; self.hidden = false,
            DialogMsg::Accept =&gt; {
                self.hidden = true;
                send!(parent_sender, AppMsg::Close);
            }
            DialogMsg::Cancel =&gt; self.hidden = true,
        }
    }
}
</code></pre>
<h3 id="the-widgets-4"><a class="header" href="#the-widgets-4">The widgets</a></h3>
<p>You've probably seen enough widget implementations by now to know roughly how this should look like, but because we haven't had window components let's have a look at it either way.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;DialogModel, AppModel&gt; for DialogWidgets {
    view! {
        gtk::MessageDialog {
            set_transient_for: Some(&amp;parent_widgets.main_window),
            set_modal: true,
            set_visible: watch!(!model.hidden),
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: args!(&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: args!(&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response(sender) =&gt; move |_, resp| {
                send!(sender, if resp == gtk::ResponseType::Accept {
                    DialogMsg::Accept
                } else {
                    DialogMsg::Cancel
                });
            }
        }
    }
}
</code></pre>
<p>Most notably there is the <code>args!</code> macro. It allows us to pass values to functions that take more than one argument. The macro would otherwise interpret the comma for a second argument as a new property, so we need to use <code>args!</code> here.</p>
<p>Also, we set the <code>set_transient_for</code> property, which actually uses the main window from the parent widgets. So far <code>parent_widgets</code> was an unused argument in our implementations. However in this case, it's neat to have access to the parent widgets. The dialog should set his parent window so that GTK can handle the dialog better. The GTK docs state: &quot;[set_transient_for] allows window managers to e.g. keep the dialog on top of the main window, or center the dialog over the main window&quot;. So we definitely want that and conveniently Relm4 gives us the widgets we need from the parents.</p>
<h2 id="the-main-app"><a class="header" href="#the-main-app">The main app</a></h2>
<p>Now all parts come together to form a single app. You might remember that there was a components type we always set to <code>()</code>. Now we actually make use of this type.</p>
<h3 id="the-components"><a class="header" href="#the-components">The components</a></h3>
<p>Because each app and each component can have any amount of child components we need to define a struct that stores all of our components.</p>
<pre><code class="language-rust no_run noplayground">struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}
</code></pre>
<p>To do this, just implement a struct with the components wrapped into a <code>RelmComponent</code> (which is similar to <code>RelmApp</code>). The first generic type of <code>RelmComponent</code> is the model of the component and the second one the parent model.</p>
<p>To make this work and to initialize our components, we need to implement the <code>Components</code> trait for our struct.</p>
<pre><code class="language-rust no_run noplayground">impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::new(parent_model, parent_widgets, parent_sender),
        }
    }
}
</code></pre>
<p>We just need to pass the arguments of the <code>init_components</code> function over to the <code>RelmComponent::new</code> function and the rest will be handled by Relm4.</p>
<h3 id="the-model-6"><a class="header" href="#the-model-6">The model</a></h3>
<p>Now we're looking at something familiar again, the model of the main app.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
}
</code></pre>
<p>The <code>AppModel</code> struct stores the modes the application can be in. The <code>SetMode</code> message is used by our header bar component to update the state of the main application when someone presses a button in the header bar. The <code>Close</code> message is used by the dialog component to indicate that the window should be closed.</p>
<p>And now we finally use the <code>Components</code> type of the <code>Model</code> trait.</p>
<pre><code class="language-rust no_run noplayground">impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}
</code></pre>
<p>The update function of the model is pretty straight forward.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, components: &amp;AppComponents, _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                components.dialog.send(DialogMsg::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                return false;
            }
        }
        true
    }
}
</code></pre>
<p>You see we can use <code>components.NAME.send()</code> to send messages to a child component, similar to the parent_sender we used to send messages in the other direction. Also we return <code>false</code> if our dialog component sends the <code>Close</code> message to tell Relm4 to close the application.</p>
<h3 id="the-widgets-5"><a class="header" href="#the-widgets-5">The widgets</a></h3>
<p>We're almost done! We only need to define the widgets of the main app.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: component!(Some(components.header.root_widget())),
            set_child = Some(&amp;gtk::Label) {
                set_label: watch!(&amp;format!(&quot;Placeholder for {:?}&quot;, model.mode)),
            },
            connect_close_request(sender) =&gt; move |_| {
                send!(sender, AppMsg::CloseRequest);
                gtk::Inhibit(true)
            }
        }
    }
}
</code></pre>
<p>The <code>component!</code> macro is used to interact with components. We just need to get our header bar component in place. Our dialog component does not need to be attached anywhere because the dialog lives in a separate window.</p>
<blockquote>
<p>Widgets from components are added <strong>after</strong> everything else. Because Relm4 initializes components after their parents we can only add components after the rest is already in place. This means that you sometimes might have to use methods like <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.BoxExt.html#tymethod.prepend"><code>prepend</code></a> to keep the right order because with <code>append</code> the component will always be added at the end. Yet, everything else is initialized in the right order.</p>
</blockquote>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>You now know most of the secrets that Relm4 offers. Components can be powerful and if they are implemented correctly, they are even reusable across different apps. The relm4-components crate offers several reusable components you can use in your applications. In the following chapters, we'll look at an even simpler component type called worker, how to implement reusable components yourself and how to use components with async code and multiple threads.</p>
<h2 id="the-complete-code-5"><a class="header" href="#the-complete-code-5">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, DialogExt, GtkWindowExt, ToggleButtonExt, WidgetExt};
use relm4::Sender;
use relm4::*;

enum HeaderMsg {
    View,
    Edit,
    Export,
}

struct HeaderModel {}

impl Model for HeaderModel {
    type Msg = HeaderMsg;
    type Widgets = HeaderWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for HeaderModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        HeaderModel {}
    }

    fn update(
        &amp;mut self,
        msg: HeaderMsg,
        _components: &amp;(),
        _sender: Sender&lt;HeaderMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            HeaderMsg::View =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::View));
            }
            HeaderMsg::Edit =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Edit));
            }
            HeaderMsg::Export =&gt; {
                send!(parent_sender, AppMsg::SetMode(AppMode::Export));
            }
        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;HeaderModel, AppModel&gt; for HeaderWidgets {
    view! {
        gtk::HeaderBar {
            set_title_widget = Some(&amp;gtk::Box) {
                add_css_class: &quot;linked&quot;,
                append: group = &amp;gtk::ToggleButton {
                    set_label: &quot;View&quot;,
                    set_active: true,
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::View);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Edit&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Edit);
                        }
                    },
                },
                append = &amp;gtk::ToggleButton {
                    set_label: &quot;Export&quot;,
                    set_group: Some(&amp;group),
                    connect_toggled(sender) =&gt; move |btn| {
                        if btn.is_active() {
                            send!(sender, HeaderMsg::Export);
                        }
                    },
                },
            }
        }
    }
}

struct DialogModel {
    hidden: bool,
}

enum DialogMsg {
    Show,
    Accept,
    Cancel,
}

impl Model for DialogModel {
    type Msg = DialogMsg;
    type Widgets = DialogWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for DialogModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        DialogModel { hidden: true }
    }

    fn update(
        &amp;mut self,
        msg: DialogMsg,
        _components: &amp;(),
        _sender: Sender&lt;DialogMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {
            DialogMsg::Show =&gt; self.hidden = false,
            DialogMsg::Accept =&gt; {
                self.hidden = true;
                send!(parent_sender, AppMsg::Close);
            }
            DialogMsg::Cancel =&gt; self.hidden = true,
        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;DialogModel, AppModel&gt; for DialogWidgets {
    view! {
        gtk::MessageDialog {
            set_transient_for: Some(&amp;parent_widgets.main_window),
            set_modal: true,
            set_visible: watch!(!model.hidden),
            set_text: Some(&quot;Do you want to close before saving?&quot;),
            set_secondary_text: Some(&quot;All unsaved changes will be lost&quot;),
            add_button: args!(&quot;Close&quot;, gtk::ResponseType::Accept),
            add_button: args!(&quot;Cancel&quot;, gtk::ResponseType::Cancel),
            connect_response(sender) =&gt; move |_, resp| {
                send!(sender, if resp == gtk::ResponseType::Accept {
                    DialogMsg::Accept
                } else {
                    DialogMsg::Cancel
                });
            }
        }
    }
}

struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::new(parent_model, parent_widgets, parent_sender),
        }
    }
}

#[derive(Debug)]
enum AppMode {
    View,
    Edit,
    Export,
}

enum AppMsg {
    SetMode(AppMode),
    CloseRequest,
    Close,
}

struct AppModel {
    mode: AppMode,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            set_default_width: 500,
            set_default_height: 250,
            set_titlebar: component!(Some(components.header.root_widget())),
            set_child = Some(&amp;gtk::Label) {
                set_label: watch!(&amp;format!(&quot;Placeholder for {:?}&quot;, model.mode)),
            },
            connect_close_request(sender) =&gt; move |_| {
                send!(sender, AppMsg::CloseRequest);
                gtk::Inhibit(true)
            }
        }
    }
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, components: &amp;AppComponents, _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::SetMode(mode) =&gt; {
                self.mode = mode;
            }
            AppMsg::CloseRequest =&gt; {
                components.dialog.send(DialogMsg::Show).unwrap();
            }
            AppMsg::Close =&gt; {
                return false;
            }
        }
        true
    }
}

fn main() {
    let model = AppModel {
        mode: AppMode::View,
    };
    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workers"><a class="header" href="#workers">Workers</a></h1>
<p>Workers are simply components that don't have any widgets. They don't have any advantages over components apart from being simpler and a few performance benefits they get from not having to call the view function (because they don't have widgets).</p>
<p>You might wonder why they even exist. We're talking about a GUI library all the time, right? Well, they can be quite useful for applications that need to handle long tasks while remaining responsive. Imagine your web browser would be completely frozen while it loads content from a slow website. This would in fact happen if you would send the HTTP requests in your update function. If you use a worker for that instead, it could handle the requests from a different thread and send a message back once finished.</p>
<h2 id="implementing-a-worker"><a class="header" href="#implementing-a-worker">Implementing a worker</a></h2>
<p>A worker is implemented similar to a component. One difference is that you use <code>()</code> as a placeholder for the <code>Widgets</code> type in the <code>Model</code> trait. Also, since you don't have widgets for the worker, you don't need to implement the <code>Widgets</code> trait.</p>
<pre><code class="language-rust no_run noplayground">impl Model for WorkerModel {
    type Msg = WorkerMsg;
    type Widgets = ();
    type Components = ();
}
</code></pre>
<p>The last difference is that worker don't need the parent widgets in the <code>RelmWorker::new</code> function. So to initialize a worker with the <code>Components</code> trait you only pass two arguments.</p>
<pre><code class="language-rust no_run noplayground">impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        _parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            worker: RelmWorker::new(parent_model, parent_sender),
        }
    }
}
</code></pre>
<p>Apart from that workers are just like components so I won't discuss an example here. You just need to define the messages you want the parent to send to the worker and handle them in the update function. There you can also send messages back to the parent component or the main app to signal that the worker has finished its work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-handlers"><a class="header" href="#message-handlers">Message handlers</a></h1>
<p>We've already seen that workers are basically components without widgets. In this chapter, we will talk about message handlers that are even simpler: like workers but without a model.</p>
<h2 id="the-motivation"><a class="header" href="#the-motivation">The motivation</a></h2>
<p>You might wonder why we even need message handlers. Components and workers are already some kind of message handlers, right? That's true, but components and workers do more than just handling messages: they also have a model that represents their state.</p>
<p>The problem with the state is that Rust doesn't like sharing mutable data. Only one mutable reference can exist at the time to prevent race conditions and other bugs. However, both components and workers can update their state in the update function while handling messages. This means that components and workers can only handle one message at the time. Otherwise, there would be multiple mutable references to the model.</p>
<p>Handling one message at the time is perfectly fine in most cases. However, if you, for example, want to handle a lot of HTTP requests and you send one message to a worker for each request you want to handle, that'd mean that one message is sent after another. This could cause a huge delay. Fortunately, message handlers can solve this issue.</p>
<h2 id="implementing-a-message-handler"><a class="header" href="#implementing-a-message-handler">Implementing a message handler</a></h2>
<p>To keep it simple, we will create another counter app. Yet this time, every click will be delayed by one second. If a user clicks the increment button, the counter will be incremented exactly one second later.</p>
<p><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/non_blocking_async.rs">here</a>. Run <code>cargo run --example non_blocking_async</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h3 id="the-timing"><a class="header" href="#the-timing">The timing</a></h3>
<p>Let's have a look at a simple timing diagram that shows what would happen if we used a worker for our app.</p>
<p><img src="img/blocking_timing.svg" alt="Blocking timing diagram" /></p>
<p>All three clicks happen in one second. But because we can only handle one message at a time in a worker, we have to wait one second, only for processing the first message. The second and the third message are then handled too late because our worker was <strong>blocking</strong> while handling the first message (see the striped parts in the diagram).</p>
<p>But how would our ideal timing diagram look like?</p>
<p><img src="img/non_blocking_timing.svg" alt="Blocking timing diagram" /></p>
<p>In the second diagram, there's no blocking. The second and the third message are handled instantly, so they can increment the counter exactly one second after the user clicked the button for the second and third time.</p>
<p>Alright, let's implement it!</p>
<h3 id="the-includes"><a class="header" href="#the-includes">The includes</a></h3>
<p>In this example, the includes are a little special because we have two kinds of senders. We've already seen <code>relm4::Sender</code> (aka <code>glib::Sender</code>) several times as it's used by Relm4 to send messages to components and workers. The other one is <code>tokio::sync::mpsc::Sender</code>, the sender we use for the message handler. We could use any sender type we want for the message handler because we're implementing all of the message handling ourselves. Yet, because we want a sender that supports async Rust, the sender from <a href="https://docs.rs/tokio/1.11.0/tokio/sync/mpsc/struct.Sender.html">tokio</a> is a reasonable choice.</p>
<p>Since both senders are called <code>Sender</code> by default we rename the latter to <code>TokioSender</code> in the last line of the includes.</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{
    send, AppUpdate, Components, MessageHandler, Model, RelmApp, RelmMsgHandler, Sender,
    WidgetPlus, Widgets,
};

use tokio::runtime::{Builder, Runtime};
use tokio::sync::mpsc::{channel, Sender as TokioSender};
</code></pre>
<blockquote>
<p>Relm4 runs updates for workers and components on the <a href="https://gtk-rs.org/gtk4-rs/git/book/main_event_loop.html">glib main event loop</a> that's provided by GTK. Therefore, Relm4 uses <code>relm4::Sender</code> aka <a href="https://gtk-rs.org/gtk-rs-core/stable/latest/docs/glib/struct.Sender.html"><code>glib::Sender</code></a> to send messages to workers and components.</p>
</blockquote>
<h3 id="the-model-7"><a class="header" href="#the-model-7">The model</a></h3>
<p>The model and the message type are the same as in our first app.</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}
</code></pre>
<p>The update function is identical, too.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(
        &amp;mut self,
        msg: AppMsg,
        _components: &amp;AppComponents,
        _sender: Sender&lt;AppMsg&gt;,
    ) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}
</code></pre>
<h3 id="the-message-handler"><a class="header" href="#the-message-handler">The message handler</a></h3>
<p>Our message handler needs to store our sender and also the tokio runtime we use to process our messages (to keep the runtime alive).</p>
<p>And of course, we need a message type as well.</p>
<pre><code class="language-rust no_run noplayground">struct AsyncHandler {
    _rt: Runtime,
    sender: TokioSender&lt;AsyncHandlerMsg&gt;,
}

#[derive(Debug)]
enum AsyncHandlerMsg {
    DelayedIncrement,
    DelayedDecrement,
}
</code></pre>
<p>Then we need to implement the <code>MessageHandler</code> trait for our message handler.</p>
<pre><code class="language-rust no_run noplayground">impl MessageHandler&lt;AppModel&gt; for AsyncHandler {
    type Msg = AsyncHandlerMsg;
    type Sender = TokioSender&lt;AsyncHandlerMsg&gt;;

    fn init(_parent_model: &amp;AppModel, parent_sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let (sender, mut rx) = channel::&lt;AsyncHandlerMsg&gt;(10);

        let rt = Builder::new_multi_thread()
            .worker_threads(8)
            .enable_time()
            .build()
            .unwrap();

        rt.spawn(async move {
            while let Some(msg) = rx.recv().await {
                let parent_sender = parent_sender.clone();
                tokio::spawn(async move {
                    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                    match msg {
                        AsyncHandlerMsg::DelayedIncrement =&gt; {
                            send!(parent_sender, AppMsg::Increment);
                        }
                        AsyncHandlerMsg::DelayedDecrement =&gt; {
                            send!(parent_sender, AppMsg::Decrement);
                        }
                    }
                });
            }
        });

        AsyncHandler { _rt: rt, sender }
    }

    fn send(&amp;self, msg: Self::Msg) {
        self.sender.blocking_send(msg).unwrap();
    }

    fn sender(&amp;self) -&gt; Self::Sender {
        self.sender.clone()
    }
}
</code></pre>
<p>First we define the message type. Then we specify the sender type. You could, for example, use <code>std::sync::mpsc::Sender</code>, <code>tokio::sync::mpsc::Sender</code> or any other sender type you want.</p>
<p>The <code>init</code> function simply initializes the message handler. In the first part, we create a new tokio runtime that will process our messages. Then we check for messages in a loop.</p>
<pre><code class="language-rust no_run noplayground">            while let Some(msg) = rx.recv().await {
</code></pre>
<p>When using components and workers, this loop runs in the background. Here we need to define it ourselves. The important part here is the <code>await</code>. Because we wait for new messages here, the tokio runtime can process our messages in the meantime. Therefore, we can handle a lot of messages at the same time.</p>
<blockquote>
<p>If you want to learn more about async in Rust, you can find more information <a href="https://rust-lang.github.io/async-book/">here</a>.</p>
</blockquote>
<p>Inside the loop, we process the message by waiting one second and then sending a message back to the parent component.</p>
<p>The <code>send</code> method defines a convenient interface for sending messages to this message handler and the <code>sender</code> method provides a sender to connect events later.</p>
<h3 id="the-components-1"><a class="header" href="#the-components-1">The components</a></h3>
<p>Next, we need to add the message handler to our components. It's very similar to adding workers.</p>
<pre><code class="language-rust no_run noplayground">struct AppComponents {
    async_handler: RelmMsgHandler&lt;AsyncHandler, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        _parent_widget: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            async_handler: RelmMsgHandler::new(parent_model, parent_sender),
        }
    }
}
</code></pre>
<h3 id="the-widgets-6"><a class="header" href="#the-widgets-6">The widgets</a></h3>
<p>The last part we need is the widgets type. It should look familiar except for the events.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
            gtk::ApplicationWindow {
                set_title: Some(&quot;Simple app&quot;),
                set_default_width: 300,
                set_default_height: 100,
                set_child = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    set_margin_all: 5,
                    set_spacing: 5,

                    append = &amp;gtk::Button {
                        set_label: &quot;Increment&quot;,
                        connect_clicked[sender = components.async_handler.sender()] =&gt; move |_| {
                            sender.blocking_send(AsyncHandlerMsg::DelayedIncrement)
                                .expect(&quot;Receiver dropped&quot;);
                        },
                    },
                    append = &amp;gtk::Button::with_label(&quot;Decrement&quot;) {
                        connect_clicked[sender = components.async_handler.sender()] =&gt; move |_| {
                            sender.blocking_send(AsyncHandlerMsg::DelayedDecrement)
                                .expect(&quot;Receiver dropped&quot;);
                        },
                    },
                    append = &amp;gtk::Label {
                        set_margin_all: 5,
                        set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
                    }
                },
            }
        }
}
</code></pre>
<p>We're connecting the event directly to the message handler. You could pass the message through the update function of your app and forward it to the message handler, but the macro provides a special syntax to connect events directly.</p>
<pre><code class="language-rust no_run noplayground">                        connect_clicked[sender = components.async_handler.sender()] =&gt; move |_| {
                            sender.blocking_send(AsyncHandlerMsg::DelayedIncrement)
                                .expect(&quot;Receiver dropped&quot;);
                        },
</code></pre>
<p>You'll notice that we use brackets instead of parentheses here. That tells the macro that we want to connect an event with a sender from a component. The syntax looks like this.</p>
<pre><code class="language-rust no_run noplayground">connect_name[sender_name = components.component_name.sender()] =&gt; move |_| { ... }
</code></pre>
<h3 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h3>
<p>That's it! We've implemented our first message handler.</p>
<h2 id="the-complete-code-6"><a class="header" href="#the-complete-code-6">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt, OrientableExt};
use relm4::{
    send, AppUpdate, Components, MessageHandler, Model, RelmApp, RelmMsgHandler, Sender,
    WidgetPlus, Widgets,
};

use tokio::runtime::{Builder, Runtime};
use tokio::sync::mpsc::{channel, Sender as TokioSender};

struct AppModel {
    counter: u8,
}

#[derive(Debug)]
enum AppMsg {
    Increment,
    Decrement,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}

impl AppUpdate for AppModel {
    fn update(
        &amp;mut self,
        msg: AppMsg,
        _components: &amp;AppComponents,
        _sender: Sender&lt;AppMsg&gt;,
    ) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}

struct AsyncHandler {
    _rt: Runtime,
    sender: TokioSender&lt;AsyncHandlerMsg&gt;,
}

#[derive(Debug)]
enum AsyncHandlerMsg {
    DelayedIncrement,
    DelayedDecrement,
}

impl MessageHandler&lt;AppModel&gt; for AsyncHandler {
    type Msg = AsyncHandlerMsg;
    type Sender = TokioSender&lt;AsyncHandlerMsg&gt;;

    fn init(_parent_model: &amp;AppModel, parent_sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let (sender, mut rx) = channel::&lt;AsyncHandlerMsg&gt;(10);

        let rt = Builder::new_multi_thread()
            .worker_threads(8)
            .enable_time()
            .build()
            .unwrap();

        rt.spawn(async move {
            while let Some(msg) = rx.recv().await {
                let parent_sender = parent_sender.clone();
                tokio::spawn(async move {
                    tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                    match msg {
                        AsyncHandlerMsg::DelayedIncrement =&gt; {
                            send!(parent_sender, AppMsg::Increment);
                        }
                        AsyncHandlerMsg::DelayedDecrement =&gt; {
                            send!(parent_sender, AppMsg::Decrement);
                        }
                    }
                });
            }
        });

        AsyncHandler { _rt: rt, sender }
    }

    fn send(&amp;self, msg: Self::Msg) {
        self.sender.blocking_send(msg).unwrap();
    }

    fn sender(&amp;self) -&gt; Self::Sender {
        self.sender.clone()
    }
}

struct AppComponents {
    async_handler: RelmMsgHandler&lt;AsyncHandler, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        _parent_widget: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            async_handler: RelmMsgHandler::new(parent_model, parent_sender),
        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
            gtk::ApplicationWindow {
                set_title: Some(&quot;Simple app&quot;),
                set_default_width: 300,
                set_default_height: 100,
                set_child = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    set_margin_all: 5,
                    set_spacing: 5,

                    append = &amp;gtk::Button {
                        set_label: &quot;Increment&quot;,
                        connect_clicked[sender = components.async_handler.sender()] =&gt; move |_| {
                            sender.blocking_send(AsyncHandlerMsg::DelayedIncrement)
                                .expect(&quot;Receiver dropped&quot;);
                        },
                    },
                    append = &amp;gtk::Button::with_label(&quot;Decrement&quot;) {
                        connect_clicked[sender = components.async_handler.sender()] =&gt; move |_| {
                            sender.blocking_send(AsyncHandlerMsg::DelayedDecrement)
                                .expect(&quot;Receiver dropped&quot;);
                        },
                    },
                    append = &amp;gtk::Label {
                        set_margin_all: 5,
                        set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
                    }
                },
            }
        }
}

fn main() {
    let model = AppModel { counter: 0 };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<table><thead><tr><th style="text-align: left"><em>Category</em></th><th style="text-align: center">Components</th><th style="text-align: center">Workers</th><th style="text-align: center">Message handlers</th></tr></thead><tbody>
<tr><td style="text-align: left">Run on different thread</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td style="text-align: left">Async</td><td style="text-align: center">âŒ</td><td style="text-align: center">âœ…</td><td style="text-align: center">âœ…</td></tr>
<tr><td style="text-align: left">Non-blocking message handling</td><td style="text-align: center">âŒ</td><td style="text-align: center">âŒ</td><td style="text-align: center">âœ…</td></tr>
</tbody></table>
<h2 id="when-to-use-"><a class="header" href="#when-to-use-">When to use ...</a></h2>
<ul>
<li>
<p><strong>components:</strong>
+ Abstract parts of your UI
+ The update function should be run on a different thread</p>
</li>
<li>
<p><strong>workers:</strong>
+ Handle IO-bound or CPU-intensive tasks <strong>one</strong> at the time on a different thread
+ You need a model to store state for processing messages</p>
</li>
<li>
<p><strong>message handlers:</strong>
+ Handle <strong>multiple</strong> IO-bound or CPU-intensive tasks at the time
+ All the information you need is sent inside the message</p>
</li>
</ul>
<h2 id="threads"><a class="header" href="#threads">Threads</a></h2>
<p>Workers are usually used to run tasks on a different thread to allow the main thread to run the UI. Let's see how this works!</p>
<h3 id="running-a-component-on-a-different-thread"><a class="header" href="#running-a-component-on-a-different-thread">Running a component on a different thread</a></h3>
<p>You might remember this section of code from the example application in the components chapter.</p>
<pre><code class="language-rust no_run noplayground">impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::new(parent_model, parent_widgets, parent_sender),
        }
    }
}
</code></pre>
<p>In order to run the dialog component on a new thread, we just need to change one line:</p>
<pre><code class="language-rust no_run noplayground">impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            header: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
            dialog: RelmComponent::with_new_thread(parent_model, parent_widgets, parent_sender),
        }
    }
}
</code></pre>
<p>Instead of <code>RelmComponent::new</code> we used <code>RelmComponent::with_new_thread</code>. The same is true for workers. <code>RelmWorker::new</code> runs the worker on the same thread and <code>RelmWorker::with_new_thread</code> spawns a new thread for the worker.</p>
<blockquote>
<p>Components have widgets that, in the case of GTK4, neither implement <code>Send</code> nor <code>Sync</code>. That means we can't run the view function from a different thread, but only the update function that just operates on the model. Internally, Relm4 sends the model from a new thread that handles the update function to the main thread that then handles the view function and back to the new thread again. This is not optimal regarding performance and therefore only recommended if you don't send a lot of messages to the component. Alternatively, you can always do the heavy work in a worker or a message handler because they don't have this problem.</p>
</blockquote>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<p>Async update functions are exclusive for workers and message handlers currently (if you need async components please open an issue). If you enable the tokio-rt feature, you can use an <code>AsyncRelmWorker</code> type that uses an async update function from the <code>AsyncComponentUpdate</code> trait. Apart from that, they are just like normal workers that run in a new thread. The <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/tokio.rs">&quot;tokio&quot; example</a> shows how this can be used with for async HTTP requests.</p>
<h3 id="non-blocking-async"><a class="header" href="#non-blocking-async">Non blocking async</a></h3>
<p>Technically, even async workers will block the execution between messages. They can run non-blocking code from their update function but they can not handle more than one message at the time. This can be too slow in some cases. </p>
<p>For example, if you have an app that fetches the avatar images of many users and you send one message to your worker for every avatar image, the worker will fetch the images one after the other. This wouldn't be much better than blocking requests and may take some time.</p>
<p>There are three ways to improve this: </p>
<ul>
<li>Create your own async runtime in message handler. This is shown in the <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/non_blocking_async.rs">non_blocking_async example</a>.</li>
<li>Send a vector with all avatar images you need to your worker, so it can send all asynchronous requests at once.</li>
<li>Spawn a new thread for each message that sends a HTTP request and sends a message back.</li>
</ul>
<h3 id="the-message-queue-problem"><a class="header" href="#the-message-queue-problem">The message queue problem</a></h3>
<p>Because workers tend to take a lot of time during the update function you should make sure to not bombard them with messages. Imagine you have a button in your application that allows the user to update a web page. If the user presses the button, a new request is sent by a worker that responds with a message once the request is completed. If the button can be clicked and a message is sent for each click while the worker is fetching the web page you could quickly have a lot of unprocessed messages in the queue of your worker. To avoid this, make sure to only send the message once and wait until the worker is finished.</p>
<h3 id="multiple-threads-and-async-without-workers"><a class="header" href="#multiple-threads-and-async-without-workers">Multiple threads and async without workers</a></h3>
<p>One reason you always get a new sender passed into your update function is that you can spawn a new thread and move a cloned sender into it. This can sometimes be more flexible than defining a worker or even a message handler. You can simply use <code>std::thread::spawn</code> for this or spawn any async runtime you want.</p>
<p>For example you could do this in your update function:</p>
<pre><code class="language-rust no_run noplayground">std::thread::spawn(move || {
    send_request();
    send!(sender, AppMsg::RequestComplete);
});
</code></pre>
<h3 id="async-inside-the-main-event-loop"><a class="header" href="#async-inside-the-main-event-loop">Async inside the main event loop</a></h3>
<p>GTK uses an event loop from glib to handle asynchronous events. In fact the senders we've been using all the time use channels on that event loop. This event loop also allows us to execute futures. Relm4 provides a <code>spawn_future</code> function to do exactly that. The only drawback of this is that most crates relying on a tokio runtime won't work and that the future is run on the main thread. The <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/future.rs">&quot;future&quot; example</a> shows how this can be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reusable-components"><a class="header" href="#reusable-components">Reusable components</a></h1>
<p>In this chapter, we will implement a simple alert dialog as a reusable component.</p>
<p>The alert example in the Relm4 repository implements a simple app for the reusable alert component we will write in this chapter. It's an other variant of a counter app, yet this time a dialog will be displayed if the counter does not match 42 when being closed. The main difference in the implementation is, that the dialog is implemented as component that can be reused in other applications.</p>
<p><img src="img/screenshots/reusable-alert-dark-1.png" alt="App screenshot dark" /></p>
<p>This is how the dialog looks like in the alert example:</p>
<p><img src="img/screenshots/reusable-alert-dark-2.png" alt="App screenshot dark" /></p>
<blockquote>
<p>If you want to see an alert component, very similar to the one we will write in this chapter, used inside a Relm4 application have a look at the <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/alert.rs">â€œalertâ€ example</a>. Run <code>cargo run --example alert</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<p>Reusable components donâ€™t know their parent component at the time they are implemented. So if they want to interact with their parent component, they must assume that their parent model implements a trait as an interface for the component.</p>
<h2 id="the-parent-traits"><a class="header" href="#the-parent-traits">The parent traits</a></h2>
<p>First, weâ€™ll have a look at the traits the parent component, that will eventually use this component, has to implement.</p>
<p>Because we want our component to be flexible and able to display different messages, we first define a data type for configuring our component.</p>
<pre><code class="language-rust no_run noplayground">pub struct AlertSettings {
    /// Large text
    pub text: String,
    /// Optional secondary, smaller text
    pub secondary_text: Option&lt;String&gt;,
    /// Modal dialogs freeze other windows as long they are visible
    pub is_modal: bool,
    /// Sets color of the accept button to red if the theme supports it
    pub destructive_accept: bool,
    /// Text for confirm button
    pub confirm_label: String,
    /// Text for cancel button
    pub cancel_label: String,
    /// Text for third option button. If [`None`] the third button won't be created.
    pub option_label: Option&lt;String&gt;,
}
</code></pre>
<p>Next, we define a trait for our parent model that defines the messages our component will send to respond to the parent. The trait also defines a function that passes a new configuration to our component.</p>
<pre><code class="language-rust no_run noplayground">/// Interface for the parent model
pub trait AlertParent: Model
where
    Self::Widgets: AlertParentWidgets,
{
    /// Configuration for alert component.
    fn alert_config(&amp;self) -&gt; AlertSettings;

    /// Message sent to parent if user clicks confirm button
    fn confirm_msg() -&gt; Self::Msg;

    /// Message sent to parent if user clicks cancel button
    fn cancel_msg() -&gt; Self::Msg;

    /// Message sent to parent if user clicks third option button
    fn option_msg() -&gt; Self::Msg;
}
</code></pre>
<p>Because you usually want to tell GTK to which window a dialog belongs to, we also add a trait that allows us to pass the parent window.</p>
<pre><code class="language-rust no_run noplayground">/// Get the parent window that allows setting the parent window of the dialog with
/// [`gtk::prelude::GtkWindowExt::set_transient_for`].
pub trait AlertParentWidgets {
    fn parent_window(&amp;self) -&gt; Option&lt;gtk::Window&gt;;
}
</code></pre>
<h2 id="the-model-8"><a class="header" href="#the-model-8">The model</a></h2>
<p>Our model stores whether the component is visible and the configuration.</p>
<pre><code class="language-rust no_run noplayground">pub struct AlertModel {
    settings: AlertSettings,
    is_active: bool,
}
</code></pre>
<p>The message type only exposes the <code>Show</code> message to the parent component. The <code>Response</code> message is used internally for handling user interactions, so we hide it with <code>#[doc(hidden)]</code>.</p>
<pre><code class="language-rust no_run noplayground">pub enum AlertMsg {
    /// Message sent by the parent to view the dialog
    Show,
    #[doc(hidden)]
    Response(gtk::ResponseType),
}
</code></pre>
<p>The <code>ComponentUpdate</code> trait would usually expect the parent component as a generic type. We donâ€™t know the parent component yet, so we add trait bounds to a new generic type.</p>
<pre><code class="language-rust no_run noplayground">impl&lt;ParentModel&gt; ComponentUpdate&lt;ParentModel&gt; for AlertModel
where
    ParentModel: AlertParent,
    ParentModel::Widgets: AlertParentWidgets,
{
</code></pre>
<p>For initializing our model, we get the configuration from our parent component and set <code>is_active</code> to <code>false</code>.</p>
<pre><code class="language-rust no_run noplayground">    fn init_model(parent_model: &amp;ParentModel) -&gt; Self {
        AlertModel {
            settings: parent_model.alert_config(),
            is_active: false,
        }
    }
</code></pre>
<p>The update function handles the <code>Show</code> message from our parent component and the <code>Response</code> messages generated by user interactions. It also sends the appropriate messages to the parent.</p>
<pre><code class="language-rust no_run noplayground">    fn update(
        &amp;mut self,
        msg: AlertMsg,
        _components: &amp;(),
        _sender: Sender&lt;AlertMsg&gt;,
        parent_sender: Sender&lt;ParentModel::Msg&gt;,
    ) {
        match msg {
            AlertMsg::Show =&gt; {
                self.is_active = true;
            }
            AlertMsg::Response(ty) =&gt; {
                self.is_active = false;
                parent_sender
                    .send(match ty {
                        gtk::ResponseType::Accept =&gt; ParentModel::confirm_msg(),
                        gtk::ResponseType::Other(_) =&gt; ParentModel::option_msg(),
                        _ =&gt; ParentModel::cancel_msg(),
                    })
                    .unwrap();
            }
        }
    }
</code></pre>
<h2 id="the-widgets-7"><a class="header" href="#the-widgets-7">The widgets</a></h2>
<p>The widgets have a generic type for the parent component with the expected trait bounds, too. Because they are part of a public interface, we also add the <code>pub</code> attribute to the widget macro. Apart from that, there is nothing special.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget(pub)]
impl&lt;ParentModel&gt; relm4::Widgets&lt;AlertModel, ParentModel&gt; for AlertWidgets
where
    ParentModel: AlertParent,
    ParentModel::Widgets: AlertParentWidgets,
{
    view! {
        dialog = gtk::MessageDialog {
            set_transient_for: parent_widgets.parent_window().as_ref(),
            set_message_type: gtk::MessageType::Question,
            set_visible: watch!(model.is_active),
            connect_response(sender) =&gt; move |_, response| {
                send!(sender, AlertMsg::Response(response));
            },

            // Apply configuration
            set_text: Some(&amp;model.settings.text),
            set_secondary_text: model.settings.secondary_text.as_deref(),
            set_modal: model.settings.is_modal,
            add_button: args!(&amp;model.settings.confirm_label, gtk::ResponseType::Accept),
            add_button: args!(&amp;model.settings.cancel_label, gtk::ResponseType::Cancel),
        }
    }

    fn post_init() {
        if let Some(option_label) = &amp;model.settings.option_label {
            dialog.add_button(option_label, gtk::ResponseType::Other(0));
        }
        if model.settings.destructive_accept {
            let accept_widget = dialog
                .widget_for_response(gtk::ResponseType::Accept)
                .expect(&quot;No button for accept response set&quot;);
            accept_widget.add_css_class(&quot;destructive-action&quot;);
        }
    }
}
</code></pre>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Weâ€™re done! Thatâ€™s your first reusable component.</p>
<blockquote>
<p>You can find more examples of reusable components in the relm4-components crate <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-components">here</a>. You can also contribute your own reusable components to relm4-components :)</p>
</blockquote>
<h2 id="the-complete-code-7"><a class="header" href="#the-complete-code-7">The complete code</a></h2>
<p>Letâ€™s review our code in one piece one more time to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{DialogExt, GtkWindowExt, WidgetExt};
use relm4::{send, ComponentUpdate, Model, Sender};

pub struct AlertSettings {
    /// Large text
    pub text: String,
    /// Optional secondary, smaller text
    pub secondary_text: Option&lt;String&gt;,
    /// Modal dialogs freeze other windows as long they are visible
    pub is_modal: bool,
    /// Sets color of the accept button to red if the theme supports it
    pub destructive_accept: bool,
    /// Text for confirm button
    pub confirm_label: String,
    /// Text for cancel button
    pub cancel_label: String,
    /// Text for third option button. If [`None`] the third button won't be created.
    pub option_label: Option&lt;String&gt;,
}

pub struct AlertModel {
    settings: AlertSettings,
    is_active: bool,
}

pub enum AlertMsg {
    /// Message sent by the parent to view the dialog
    Show,
    #[doc(hidden)]
    Response(gtk::ResponseType),
}

impl Model for AlertModel {
    type Msg = AlertMsg;
    type Widgets = AlertWidgets;
    type Components = ();
}

/// Interface for the parent model
pub trait AlertParent: Model
where
    Self::Widgets: AlertParentWidgets,
{
    /// Configuration for alert component.
    fn alert_config(&amp;self) -&gt; AlertSettings;

    /// Message sent to parent if user clicks confirm button
    fn confirm_msg() -&gt; Self::Msg;

    /// Message sent to parent if user clicks cancel button
    fn cancel_msg() -&gt; Self::Msg;

    /// Message sent to parent if user clicks third option button
    fn option_msg() -&gt; Self::Msg;
}

/// Get the parent window that allows setting the parent window of the dialog with
/// [`gtk::prelude::GtkWindowExt::set_transient_for`].
pub trait AlertParentWidgets {
    fn parent_window(&amp;self) -&gt; Option&lt;gtk::Window&gt;;
}

impl&lt;ParentModel&gt; ComponentUpdate&lt;ParentModel&gt; for AlertModel
where
    ParentModel: AlertParent,
    ParentModel::Widgets: AlertParentWidgets,
{
    fn init_model(parent_model: &amp;ParentModel) -&gt; Self {
        AlertModel {
            settings: parent_model.alert_config(),
            is_active: false,
        }
    }

    fn update(
        &amp;mut self,
        msg: AlertMsg,
        _components: &amp;(),
        _sender: Sender&lt;AlertMsg&gt;,
        parent_sender: Sender&lt;ParentModel::Msg&gt;,
    ) {
        match msg {
            AlertMsg::Show =&gt; {
                self.is_active = true;
            }
            AlertMsg::Response(ty) =&gt; {
                self.is_active = false;
                parent_sender
                    .send(match ty {
                        gtk::ResponseType::Accept =&gt; ParentModel::confirm_msg(),
                        gtk::ResponseType::Other(_) =&gt; ParentModel::option_msg(),
                        _ =&gt; ParentModel::cancel_msg(),
                    })
                    .unwrap();
            }
        }
    }
}

#[relm4_macros::widget(pub)]
impl&lt;ParentModel&gt; relm4::Widgets&lt;AlertModel, ParentModel&gt; for AlertWidgets
where
    ParentModel: AlertParent,
    ParentModel::Widgets: AlertParentWidgets,
{
    view! {
        dialog = gtk::MessageDialog {
            set_transient_for: parent_widgets.parent_window().as_ref(),
            set_message_type: gtk::MessageType::Question,
            set_visible: watch!(model.is_active),
            connect_response(sender) =&gt; move |_, response| {
                send!(sender, AlertMsg::Response(response));
            },

            // Apply configuration
            set_text: Some(&amp;model.settings.text),
            set_secondary_text: model.settings.secondary_text.as_deref(),
            set_modal: model.settings.is_modal,
            add_button: args!(&amp;model.settings.confirm_label, gtk::ResponseType::Accept),
            add_button: args!(&amp;model.settings.cancel_label, gtk::ResponseType::Cancel),
        }
    }

    fn post_init() {
        if let Some(option_label) = &amp;model.settings.option_label {
            dialog.add_button(option_label, gtk::ResponseType::Other(0));
        }
        if model.settings.destructive_accept {
            let accept_widget = dialog
                .widget_for_response(gtk::ResponseType::Accept)
                .expect(&quot;No button for accept response set&quot;);
            accept_widget.add_css_class(&quot;destructive-action&quot;);
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtk-rs-overview"><a class="header" href="#gtk-rs-overview">gtk-rs overview</a></h1>
<p>So far, we only discussed which features Relm4 provides. Yet, Relm4 is based on GTK, which itself has many useful features. Letâ€™s have a look at it!</p>
<blockquote>
<p>This is just an overview. Iâ€™ve linked the relevant sections of the <a href="https://gtk-rs.org/gtk4-rs/git/book/">gtk-rs book</a> but if you want to get familiar with all the features, I recommend reading the book from the start.</p>
</blockquote>
<h2 id="gobjects"><a class="header" href="#gobjects">GObjects</a></h2>
<p>GTK is an object-oriented framework that uses the GObject library to implement objects. GObjects have some really useful features that we will discuss in the following sections.</p>
<h3 id="subclassing"><a class="header" href="#subclassing">Subclassing</a></h3>
<p>Like many other OOP frameworks or languages, GObjects can inherit from other GObjects. This is called subclassing. In the case of GTK, thatâ€™s really helpful because it allows us to create custom widgets. </p>
<p>For example, you could use subclassing to create your own button widget that acts as a counter. Or you can create a custom application window that better suits your application.</p>
<p><strong>Read more about subclassing in the <a href="https://gtk-rs.org/gtk4-rs/git/book/gobject_subclassing.html">gtk-rs book</a></strong>.</p>
<h3 id="properties-1"><a class="header" href="#properties-1">Properties</a></h3>
<p>Each GObject can have properties that work similar to the fields of a structure in Rust. You can set them and you can read (get) them. But one thing that's particularly cool is that properties can be bound to other properties.</p>
<p>For example, you could bind the &quot;visible&quot; property of a widget to the &quot;active&quot; property of a <code>gtk::ToggleButton</code>. This would allow you to show or hide the widget using the toggle button and the best part is, that it's done fully automatically!</p>
<p><strong>Read more about properties in the <a href="https://gtk-rs.org/gtk4-rs/git/book/gobject_properties.html">gtk-rs book</a></strong>.</p>
<h3 id="signals"><a class="header" href="#signals">Signals</a></h3>
<p>GObjects can not only have properties but also signals. Actually, we've been using signals all the time, for example, by using the <code>connect_clicked</code> method on a button. This method simply adds an event handler function for the &quot;click&quot; signal.</p>
<p>You can create your own signals in custom widgets. You can also use <a href="https://gtk-rs.org/gtk-rs-core/git/docs/glib/object/trait.ObjectExt.html#tymethod.emit">emit</a> to emit signals on you widgets manually.</p>
<p><strong>Read more about signals in the <a href="https://gtk-rs.org/gtk4-rs/git/book/gobject_signals.html">gtk-rs book</a></strong>.</p>
<h2 id="settings"><a class="header" href="#settings">Settings</a></h2>
<p>Most applications need to store settings at some point. GTK makes that pretty simple. You can use <code>gtk::Settings</code> to store your settings and keep them stored after your app has been closed.</p>
<p><strong>Read more about settings in the <a href="https://gtk-rs.org/gtk4-rs/git/book/settings.html">gtk-rs book</a></strong>.</p>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Relm4 has factories for generating widgets from collections of data. GTK has a similar mechanism that should be used for large list. Because GTK knows which widgets of a list are actually shown it can optimize the rendering and memory usage a lot better.</p>
<p><strong>Read more about lists in the <a href="https://gtk-rs.org/gtk4-rs/git/book/lists.html">gtk-rs book</a></strong>.</p>
<h2 id="interface-builder"><a class="header" href="#interface-builder">Interface builder</a></h2>
<p>Relm4 leaves it up to you how to create you UI. You can do it manually like in our first app, you can do with the widget macro or you can use the interface builder from GTK.</p>
<p>With the interface builder, you can use a XML file to specify your widgets and properties.</p>
<p><strong>Read more about the interface builder in the <a href="https://gtk-rs.org/gtk4-rs/git/book/interface_builder.html">gtk-rs book</a></strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-widget-macro-reference"><a class="header" href="#the-widget-macro-reference">The widget macro reference</a></h1>
<p>There are quite a lot of examples where the widget macro is used in this book. Yet, we haven't covered everything in the previous chapters and having all the information in one place is nice, too.</p>
<h2 id="property-names"><a class="header" href="#property-names">Property names</a></h2>
<p>The widget macros uses setter methods of gtk4-rs. You can find them at the <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/index.html">gtk4-rs docs</a>.</p>
<p>Many properties are also part of a trait. Make sure that this trait is in scope. In many cases you need to <code>use gtk::prelude::TraitName</code>.</p>
<p>For example, if you want to use the <a href="https://gtk-rs.org/gtk4-rs/git/docs/gtk4/prelude/trait.GtkWindowExt.html#tymethod.set_default_width"><code>set_default_width</code></a> method of the <code>GtkWindowExt</code> trait you need to <code>use gtk::prelude::GtkWindowExt</code>.</p>
<h3 id="trait-disambiguation"><a class="header" href="#trait-disambiguation">Trait disambiguation</a></h3>
<p>Sometimes you use several traits that implement the same method for a type so you need to tell Rust which trait it should use. For example the <code>set_child</code> function is implemented by both <code>gtk::prelude::GtkWindowExt</code> and <code>libadwaita::traits::ApplicationWindowExt</code>. If we use the regular syntax, the Rust compiler will get confused and tells us to specify the trait. So instead we use the <code>TraitName::method</code> syntax that's similar to <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Rust's fully qualified syntax for trait disambiguation</a>.</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use libadwaita::traits::ApplicationWindowExt;
</span>ApplicationWindowExt::set_child = Some(&amp;gtk::Box) { ... }
</code></pre>
<p>You can also use the full path of the trait.</p>
<pre><code class="language-rust no_run noplayground">libadwaita::traits::ApplicationWindowExt::set_child = Some(&amp;gtk::Box) { ... }
</code></pre>
<h2 id="public-widgets"><a class="header" href="#public-widgets">Public widgets</a></h2>
<p>If you want to make the widgets struct generated by the macro public, you can simply use <code>pub</code> as an attribute for the macro.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget(pub)]
</code></pre>
<h2 id="assign-properties"><a class="header" href="#assign-properties">Assign properties</a></h2>
<p>Initialize a property with a value:</p>
<pre><code class="language-rust no_run noplayground">property_name: value,
</code></pre>
<p>Initialize an optional property only if it's <code>Some</code> and ignore if it's none:</p>
<pre><code class="language-rust no_run noplayground">property_name?: value,
</code></pre>
<p>Initialize a property that has multiple properties:</p>
<pre><code class="language-rust no_run noplayground">property_name: args!(value1, value2, ...),
</code></pre>
<p>Initialize and automatically update a property:</p>
<pre><code class="language-rust no_run noplayground">property_name: watch!(value1, value2, ...),
</code></pre>
<p>Initialize and automatically update a property with a tracker. The track_expression can be any expression that returns a bool. If it's true, it indicates, that the property should be updated:</p>
<pre><code class="language-rust no_run noplayground">property_name: track!(track_expression, value1, value2, ...),
</code></pre>
<p>Initialize a property by iterating over an iterator. You can use this for repeated calls to setter functions, like <code>add_class_name</code> in case you have multiple class names in a <code>Vec</code>.</p>
<pre><code class="language-rust no_run noplayground">property_name: iterate!(iterator),
</code></pre>
<h2 id="add-widgets"><a class="header" href="#add-widgets">Add widgets</a></h2>
<p>Without name:</p>
<pre><code class="language-rust no_run noplayground">property_name = gtk::Box { ... }
</code></pre>
<blockquote>
<p>A common mistake is to accidentally use <code>:</code> instead of <code>=</code> for assigning widgets.</p>
</blockquote>
<p>With name:</p>
<pre><code class="language-rust no_run noplayground">property_name: name = gtk::Box { ... }
</code></pre>
<p>As reference:</p>
<pre><code class="language-rust no_run noplayground">property_name = &amp;gtk::Box { ... }
</code></pre>
<p>As <code>Option</code>:</p>
<pre><code class="language-rust no_run noplayground">property_name = Some(gtk::Box) { ... }
</code></pre>
<p>As reference in an <code>Option</code>:</p>
<pre><code class="language-rust no_run noplayground">property_name = Some(&amp;gtk::Box) { ... }
</code></pre>
<p>Pass additional arguments with the widget. This will call <code>widget.property_name(box_widget, value1, value2, ...)</code> and can be used to call <a href="https://aaronerhardt.github.io/docs/relm4/gtk4/prelude/trait.GridExt.html#tymethod.attach">attach</a> on a <code>gtk::Grid</code> for example.</p>
<pre><code class="language-rust no_run noplayground">property_name(value1, value2, ...) = gtk::Box { ... }
property_name(value1, value2, ...): name = gtk::Box { ... }
</code></pre>
<p>The type of the widget created in all the examples above will always be <code>gtk::Box</code>. However, some properties are set with references or references in <code>Options</code> where this syntax becomes handy.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Sometimes there's no default implementation for a widget, so you need a constructor or you want to pass a function that returns the widget.</p>
<p>If the function is associated with a type, you can simply use this syntax. The macro will assume the type of <code>gtk::Box::new()</code> is <code>gtk::Box</code>:</p>
<pre><code class="language-rust no_run noplayground">property_name = gtk::Box::new() { ... }
</code></pre>
<p>For some functions, the macro can't guess the type or might even assume a wrong type. In such a case, add the type to your function:</p>
<pre><code class="language-rust no_run noplayground">property_name = new_box() -&gt; gtk::Box { ... }
</code></pre>
<h2 id="connecting-events"><a class="header" href="#connecting-events">Connecting events</a></h2>
<p>When connecting events you can clone elements you need in the closure by putting it into the parentheses.</p>
<pre><code class="language-rust no_run noplayground">connect_name(cloned_var1, cloned_var2, ...) =&gt; move |arg1, arg2, ...| { ... }
</code></pre>
<h3 id="connecting-to-components"><a class="header" href="#connecting-to-components">Connecting to components</a></h3>
<p>For connecting events directly to components you need to use brackets. In the brackets you can create new sender variables from the senders of your components.</p>
<pre><code class="language-rust no_run noplayground">connect_name[sender1 = components.name1.sender(), 
    sender2 = components.name2.sender(), ...] =&gt; move |arg1, arg2, ...|
</code></pre>
<h3 id="the-send-macro"><a class="header" href="#the-send-macro">The send macro</a></h3>
<p>The send macro simply provides some syntactical sugar. This code </p>
<pre><code class="language-rust no_run noplayground">send!(sender, AppMsg::Increment)
</code></pre>
<p>expands to this code:</p>
<pre><code class="language-rust no_run noplayground">sender.send(AppMsg::Increment).expect(&quot;Receiver was dropped!&quot;)
</code></pre>
<p>The unwrap is save because send errors should never happen, especially because Relm4 usually keeps the receiver alive.</p>
<h2 id="factories"><a class="header" href="#factories">Factories</a></h2>
<pre><code class="language-rust no_run noplayground">property_name = gtk::Box { 
    factory!(model.data)
}
</code></pre>
<h2 id="manual"><a class="header" href="#manual">Manual</a></h2>
<p>Sometimes the macro isn't flexible enough. In this case, you can always use manual code that will not be modified by the macro.</p>
<p>Here's a list of all the options available.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        // ...
    }

    additional_fields! {
        // ...
    }

    fn pre_init() {
        // ...
    }

    fn post_init() {
        // ...
    }

    fn manual_view() {
        // ...
    }
}
</code></pre>
<h3 id="run-custom-initialization-code"><a class="header" href="#run-custom-initialization-code">Run custom initialization code</a></h3>
<p>You can use the <code>pre_init</code> function inside the widgets macro to run code before the initialization of the view macro starts. This is useful if you want to generate values you later use in the view macro.</p>
<pre><code class="language-rust no_run noplayground">fn pre_init() {
    // ...
}
</code></pre>
<p>You can use the <code>post_init</code> function to run code after the initialization of the view macro. This can be used to modify the widgets generated by the view macro for manual initialization. All variables and widget names used in the view macro and the <code>pre_init</code> function can still be used here.</p>
<pre><code class="language-rust no_run noplayground">fn post_init() {
    // ...
}
</code></pre>
<h3 id="add-more-fields-to-your-widgets"><a class="header" href="#add-more-fields-to-your-widgets">Add more fields to your widgets</a></h3>
<p>The widgets struct is automatically generated by the macro, but sometimes you want to add your own fields. To do so, use the <code>additional_fields!</code> macro:</p>
<pre><code class="language-rust no_run noplayground">additional_fields! {
    test: u8,
}
</code></pre>
<p>To initialize the variable, you can use either <code>pre_init</code> or <code>post_init</code>. Simply name a local variable like your custom field. I this case we could simply do this:</p>
<pre><code class="language-rust no_run noplayground">fn post_init() {
    let test = 0;
}
</code></pre>
<p>The macro will then put all parts together to create the widgets struct and the <code>init_view</code> function.</p>
<pre><code class="language-rust no_run noplayground">struct AppWidgets {
    ...
    test: u8,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    ...
    fn init_view(model: &amp;AppModel, parent_widgets: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        ...
        let test = 0;
        AppWidgets {
            ...
            test,
        }
    }
    ...
}
</code></pre>
<h3 id="manual-view"><a class="header" href="#manual-view">Manual view</a></h3>
<p>You can also implement your own view logic that's added to the view code the view macro generates. To refer to the widgets, use <code>self</code> and <code>model</code> for the model.</p>
<pre><code class="language-rust no_run noplayground">fn manual_view() {
    // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro-expansion"><a class="header" href="#macro-expansion">Macro expansion</a></h1>
<p>To better understand the widget macro, we will have a look at how the different parts of the widget macro are translated into real Rust code (aka the macro expansion). Therefore, we will write a small app that uses as many widget macro features as possible.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/macro_test.rs">here</a>. Run <code>cargo run --example macro_test</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="the-boilerplate"><a class="header" href="#the-boilerplate">The boilerplate</a></h2>
<p>First, let's have a look at the parts of the code that are later used by the macro.</p>
<h3 id="the-model-9"><a class="header" href="#the-model-9">The model</a></h3>
<p>The model stores a counter, several class names and a decrement field that will indicate if the counter was last decremented or not. This will be used later in a tracker that only updates when the user decrements the counter.</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
    classes: Vec&lt;&amp;'static str&gt;,
    decrement: bool,
}
</code></pre>
<h3 id="the-message-type-2"><a class="header" href="#the-message-type-2">The message type</a></h3>
<p>The message type is the same as in our first app.</p>
<pre><code class="language-rust no_run noplayground">enum AppMsg {
    Increment,
    Decrement,
}
</code></pre>
<h3 id="the-update-function-3"><a class="header" href="#the-update-function-3">The update function</a></h3>
<p>The update function is very simple, too. The only difference is that we set the decrement field to <code>true</code> if the <code>Decrement</code> message was sent.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(
        &amp;mut self,
        msg: AppMsg,
        _components: &amp;AppComponents,
        _sender: Sender&lt;AppMsg&gt;,
    ) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
                self.decrement = false;
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
                self.decrement = true;
            }
        }
        true
    }
}
</code></pre>
<h3 id="the-component"><a class="header" href="#the-component">The component</a></h3>
<p>We will use a minimal button component that just has a button as widget to showcase the <code>component!</code> macro later.</p>
<pre><code class="language-rust no_run noplayground">enum ButtonMsg {}

struct ButtonModel {}

impl Model for ButtonModel {
    type Msg = ButtonMsg;
    type Widgets = ButtonWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for ButtonModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        ButtonModel {}
    }

    fn update(
        &amp;mut self,
        _msg: ButtonMsg,
        _components: &amp;(),
        _sender: Sender&lt;ButtonMsg&gt;,
        _parent_sender: Sender&lt;AppMsg&gt;,
    ) {
    }
}

#[relm4_macros::widget]
impl Widgets&lt;ButtonModel, AppModel&gt; for ButtonWidgets {
    view! {
        gtk::Button {
            set_label: &quot;ButtonComponent!&quot;,
        }
    }
}

pub struct AppComponents {
    button1: RelmComponent&lt;ButtonModel, AppModel&gt;,
    button2: RelmComponent&lt;ButtonModel, AppModel&gt;,
}
</code></pre>
<h3 id="a-custom-widget-function"><a class="header" href="#a-custom-widget-function">A custom widget function</a></h3>
<p>Also, we add a small function that simply returns a <code>gtk::Label</code>.</p>
<pre><code class="language-rust no_run noplayground">fn new_label() -&gt; gtk::Label {
    gtk::Label::new(Some(&quot;test&quot;))
}
</code></pre>
<h2 id="the-macro"><a class="header" href="#the-macro">The macro</a></h2>
<p>Let's have a look at the whole macro before we will break it down into smaller parts. If you're unfamiliar with the macro syntax, have a look at the previous chapter.</p>
<pre><code class="language-rust no_run noplayground">#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
            main_window = gtk::ApplicationWindow {
                gtk::prelude::GtkWindowExt::set_title: Some(&quot;Simple app&quot;),
                set_default_width: 300,
                set_default_height: 100,
                set_child = Some(&amp;gtk::Box) {
                    set_orientation: gtk::Orientation::Vertical,
                    set_margin_all?: Some(5),
                    set_spacing: 5,

                    append: component!(components.button1.root_widget()),
                    append: inc_button = &amp;gtk::Button {
                        set_label: &quot;Increment&quot;,
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::Increment);
                        },
                        add_css_class: iterate!(&amp;model.classes),
                    },
                    append = &amp;gtk::Button::new() {
                        set_label: track!(model.decrement, &amp;format!(&quot;Last decrement at {}&quot;, model.counter)),
                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::Decrement);
                        },
                    },
                    append = &amp;new_label() -&gt; gtk::Label {
                        set_margin_all: 5,
                        set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
                    },
                    append = &amp;gtk::Grid {
                        set_vexpand: true,
                        set_hexpand: true,
                        set_row_spacing: 10,
                        set_column_spacing: 10,
                        set_column_homogeneous: true,
                        attach(1, 1, 1, 1) = &amp;gtk::Label {
                            set_label: &quot;grid test 1&quot;,
                        },
                        attach(1, 2, 1, 1) = &amp;gtk::Label {
                            set_label: &quot;grid test 2&quot;,
                        },
                        attach(2, 1, 1, 1) = &amp;gtk::Label {
                            set_label: &quot;grid test 3&quot;,
                        },
                        attach(2, 2, 1, 1): component!(components.button2.root_widget())
                    }
                },
            }
        }

    additional_fields! {
        test_field: u8,
    }

    fn pre_init() {
        let mut test_field = 0;
        println!(&quot;Pre init! test_field: {}&quot;, test_field);
    }

    fn post_init() {
        relm4::set_global_css(b&quot;.first { color: green; } .second { border: 1px solid orange; }&quot;);
        test_field = 42;
        println!(&quot;Post init! test_field: {}&quot;, test_field);
    }

    fn manual_view() {
        self.test_field += 1;
        println!(&quot;Manual view! test_field: {}&quot;, self.test_field);
    }
}
</code></pre>
<h2 id="the-expansion"><a class="header" href="#the-expansion">The expansion</a></h2>
<p>The macro expansion is not supposed to be readable, so the code might look a bit ugly.</p>
<h3 id="the-widgets-struct"><a class="header" href="#the-widgets-struct">The widgets struct</a></h3>
<p>The fields of the widgets struct cover all widgets we created, plus the additional fields we added manually. Names fields like <code>main_window</code> and <code>inc_button</code> keep their names. Unnamed fields will get automatically generated names with an unique ID. You should never refer to unnamed fields in your code because their names might change. At the end, we can find the additional field called <code>test_field</code> that we added manually.</p>
<pre><code class="language-rust no_run noplayground">#[allow(dead_code)]
struct AppWidgets {
    main_window: gtk::ApplicationWindow,
    _gtk_box_7: gtk::Box,
    inc_button: gtk::Button,
    _gtk_button_new_1: gtk::Button,
    _new_label_2: gtk::Label,
    _gtk_grid_6: gtk::Grid,
    _gtk_label_3: gtk::Label,
    _gtk_label_4: gtk::Label,
    _gtk_label_5: gtk::Label,
    test_field: u8,
}
</code></pre>
<h3 id="the-widgets-trait-implementation"><a class="header" href="#the-widgets-trait-implementation">The <code>Widgets</code> trait implementation</a></h3>
<p>The next thing the macro does is generating the <code>Widgets</code> trait implementation block.</p>
<p>The start of the implementation block is very similar to the implementation block we use in the macro. Most notably, the <code>Root</code> type is automatically inserted. All attributes and comments you add to the widget macro before the <code>impl</code> block should be kept as well.</p>
<pre><code class="language-rust no_run noplayground">impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;
</code></pre>
<h4 id="pre-initialization"><a class="header" href="#pre-initialization">Pre-initialization</a></h4>
<p>At the start of the view initialization, we find â€” to no surprise â€” the code of the <code>pre_init()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    /// Initialize the UI.
    fn init_view(
        model: &amp;AppModel,
        parent_widgets: &amp;(),
        sender: ::gtk::glib::Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        let mut test_field = 0;
        println!(&quot;Pre init! test_field: {}&quot;, test_field);
</code></pre>
<p>It's exactly the the code of the <code>pre_init()</code> function.</p>
<pre><code class="language-rust no_run noplayground">    fn pre_init() {
        let mut test_field = 0;
        println!(&quot;Pre init! test_field: {}&quot;, test_field);
    }
</code></pre>
<h4 id="widget-initialization"><a class="header" href="#widget-initialization">Widget initialization</a></h4>
<p>The macro now initializes all widgets. Widgets that were defined by their type are initialized with the <a href="https://aaronerhardt.github.io/docs/relm4/relm4/util/default_widgets/trait.DefaultWidget.html"><code>relm4::util::default_widgets::DefaultWidget</code></a> trait that basically calls <code>Widget::builder().build()</code> to initialize a widget with default configuration. Obviously, that only works for widgets that support this builder pattern.</p>
<p>We also see <code>gtk::Button::new()</code> and <code>new_label()</code> used to initialize widgets. These widgets were explicitly initialized with a <a href="https://aaronerhardt.github.io/relm4-book/book/widget_macro_reference.html#functions">function</a>.</p>
<pre><code class="language-rust no_run noplayground">        let main_window = gtk::ApplicationWindow::default();
        let _gtk_box_7 = gtk::Box::default();
        let inc_button = gtk::Button::default();
        let _gtk_button_new_1 = gtk::Button::new();
        let _new_label_2 = new_label();
</code></pre>
<h4 id="assigning-properties"><a class="header" href="#assigning-properties">Assigning properties</a></h4>
<p>Assigning properties looks pretty normal as well.</p>
<pre><code class="language-rust no_run noplayground">        gtk::prelude::GtkWindowExt::set_title(&amp;main_window, Some(&quot;Simple app&quot;));
        main_window.set_default_width(300);
        main_window.set_default_height(100);
        _gtk_box_7.set_orientation(gtk::Orientation::Vertical);
        if let Some(__p_assign) = Some(5) {
            _gtk_box_7.set_margin_all(__p_assign);
        }
        _gtk_box_7.set_spacing(5);
        inc_button.set_label(&quot;Increment&quot;);
        for __elem in &amp;model.classes {
            inc_button.add_css_class(__elem);
        }
</code></pre>
<p>At the start, we find the code for the assignment from the macro that uses a trait function.</p>
<pre><code class="language-rust no_run noplayground">                gtk::prelude::GtkWindowExt::set_title: Some(&quot;Simple app&quot;),
</code></pre>
<p>In the middle we have the optional assign, that uses an <code>if let</code> statement to only assign properties that match <code>Some(data)</code>. In the macro we marked this line with a <code>?</code>.</p>
<pre><code class="language-rust no_run noplayground">                    set_margin_all?: Some(5),
</code></pre>
<p>At the end we have our iterator from the macro. </p>
<pre><code class="language-rust no_run noplayground">                        add_css_class: iterate!(&amp;model.classes),
</code></pre>
<blockquote>
<p>There are some properties missing here because I only showed the relevant section for the purpose of this book.</p>
</blockquote>
<h4 id="events-1"><a class="header" href="#events-1">Events</a></h4>
<p>Now the macro generates the code for connecting events.</p>
<pre><code class="language-rust no_run noplayground">        {
            #[allow(clippy::redundant_clone)]
            let sender = sender.clone();
            inc_button.connect_clicked(move |_| {
                send!(sender, AppMsg::Increment);
            });
        }
        {
            #[allow(clippy::redundant_clone)]
            let sender = sender.clone();
            _gtk_button_new_1.connect_clicked(move |_| {
                send!(sender, AppMsg::Decrement);
            });
        }
</code></pre>
<p>The code looks very similar to what we wrote in the macro.</p>
<pre><code class="language-rust no_run noplayground">                        connect_clicked(sender) =&gt; move |_| {
                            send!(sender, AppMsg::Decrement);
                        },
</code></pre>
<p>Most notably, the sender we put in the parenthesis is cloned as we requested.</p>
<h4 id="post-initialization"><a class="header" href="#post-initialization">Post-initialization</a></h4>
<p>At the end, we find the code of our <code>post_init()</code> function.</p>
<pre><code class="language-rust no_run noplayground">        relm4::set_global_css(b&quot;.first { color: green; } .second { border: 1px solid orange; }&quot;);
        test_field = 42;
        println!(&quot;Post init! test_field: {}&quot;, test_field);
</code></pre>
<p>Again, the code is exactly the same.</p>
<pre><code class="language-rust no_run noplayground">    fn post_init() {
        relm4::set_global_css(b&quot;.first { color: green; } .second { border: 1px solid orange; }&quot;);
        test_field = 42;
        println!(&quot;Post init! test_field: {}&quot;, test_field);
    }
</code></pre>
<h4 id="return"><a class="header" href="#return">Return</a></h4>
<p>At the end, we return the widgets struct with all initialized widgets.</p>
<pre><code class="language-rust no_run noplayground">        Self {
            main_window,
            _gtk_box_7,
            inc_button,
            _gtk_button_new_1,
            _new_label_2,
            _gtk_grid_6,
            _gtk_label_3,
            _gtk_label_4,
            _gtk_label_5,
            test_field,
        }
    }
</code></pre>
<h4 id="assigning-widgets-and-components"><a class="header" href="#assigning-widgets-and-components">Assigning widgets and components</a></h4>
<p>To keep every widget in order, all widgets are assigned in <code>connect_components</code> function. In the first stable version of Relm4 (0.1.0), regular widgets were already assigned in the <code>init_view</code> function. This caused problems with the ordering of elements because components were added after all other widgets were already in place. For Relm4 0.2 this behavior was changed so that all widgets are now added at the same place so that components keep their correct order.</p>
<pre><code class="language-rust no_run noplayground">    fn connect_components(&amp;self, model: &amp;AppModel, components: &amp;&lt;AppModel as ::relm4::Model&gt;::Components) {
        self.main_window.set_child(Some(&amp;self._gtk_box_7));
        self._gtk_box_7.append(components.button1.root_widget());
        self._gtk_box_7.append(&amp;self.inc_button);
        self._gtk_box_7.append(&amp;self._gtk_button_new_1);
        self._gtk_box_7.append(&amp;self._new_label_2);
        self._gtk_box_7.append(&amp;self._gtk_grid_6);
        self._gtk_grid_6.attach(&amp;self._gtk_label_3, 1, 1, 1, 1);
        self._gtk_grid_6.attach(&amp;self._gtk_label_4, 1, 2, 1, 1);
        self._gtk_grid_6.attach(&amp;self._gtk_label_5, 2, 1, 1, 1);
        self._gtk_grid_6
            .attach(components.button2.root_widget(), 2, 2, 1, 1);
    }
</code></pre>
<p>At the beginning, we find the code for the <code>set_child</code> property we used in the macro.</p>
<pre><code class="language-rust no_run noplayground">                set_child = Some(&amp;gtk::Box) {
</code></pre>
<p>In the macro we used the nested <code>component!</code> macro to add a component to our UI. This component can now be found in the last line of the <code>connect_components</code> function.</p>
<pre><code class="language-rust no_run noplayground">                        attach(2, 2, 1, 1): component!(components.button2.root_widget())
</code></pre>
<h4 id="root-widget"><a class="header" href="#root-widget">Root widget</a></h4>
<p>The macro also implements the <code>root_widget</code> function that returns the outermost widget that is also the first we use in the <code>view!</code> macro.</p>
<pre><code class="language-rust no_run noplayground">    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.main_window.clone()
    }
</code></pre>
<h4 id="manual-ui-updates"><a class="header" href="#manual-ui-updates">Manual UI updates</a></h4>
<p>The last step of the macro is to generate the update logic with the <code>view</code> function. At the start of this function, we can find the code from the <code>manual_view()</code> function of the macro.</p>
<pre><code class="language-rust no_run noplayground">    /// Update the view to represent the updated model.
    fn view(
        &amp;mut self,
        model: &amp;AppModel,
        sender: ::gtk::glib::Sender&lt;&lt;AppModel as ::relm4::Model&gt;::Msg&gt;,
    ) {
        self.test_field += 1;
        println!(&quot;Manual view! test_field: {}&quot;, self.test_field);
</code></pre>
<p>Just like with <code>pre_init()</code> and <code>post_init()</code> the code is exactly the same, too.</p>
<pre><code class="language-rust no_run noplayground">    fn manual_view() {
        self.test_field += 1;
        println!(&quot;Manual view! test_field: {}&quot;, self.test_field);
    }
</code></pre>
<h4 id="generated-ui-updates"><a class="header" href="#generated-ui-updates">Generated UI updates</a></h4>
<p>After the manually defined update logic, the macro generates its own code.</p>
<pre><code class="language-rust no_run noplayground">        self._new_label_2
            .set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));

        if model.decrement {
            self._gtk_button_new_1
                .set_label(&amp;format!(&quot;Last decrement at {}&quot;, model.counter));
        }
</code></pre>
<p>The first update comes from the nested <code>watch!</code> macro and is unconditional.</p>
<pre><code class="language-rust no_run noplayground">                        set_label: watch! { &amp;format!(&quot;Counter: {}&quot;, model.counter) },
</code></pre>
<p>The second update rule sits behind an <code>if</code> statement because it comes from the nested <code>track!</code> macro. In this case, the condition for the tracker is simply the <code>model.decrement</code> field.</p>
<pre><code class="language-rust no_run noplayground">                        set_label: track!(model.decrement, &amp;format!(&quot;Last decrement at {}&quot;, model.counter)),
</code></pre>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Congrats for making it this far ðŸŽ‰! You're now a real expert of Relm4!</p>
<p>As you have seen, the macro is nothing magical. It simply works with the information you give to it.</p>
<h2 id="the-whole-macro-expansion"><a class="header" href="#the-whole-macro-expansion">The whole macro expansion</a></h2>
<p>If you want to look at the whole macro expansion at once, here it is.</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GridExt, GtkWindowExt, OrientableExt, WidgetExt};
use relm4::{
    send, AppUpdate, ComponentUpdate, Components, Model, RelmApp, RelmComponent, Sender,
    WidgetPlus, Widgets,
};

struct AppModel {
    counter: u8,
    classes: Vec&lt;&amp;'static str&gt;,
    decrement: bool,
}

enum AppMsg {
    Increment,
    Decrement,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}

impl AppUpdate for AppModel {
    fn update(
        &amp;mut self,
        msg: AppMsg,
        _components: &amp;AppComponents,
        _sender: Sender&lt;AppMsg&gt;,
    ) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
                self.decrement = false;
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
                self.decrement = true;
            }
        }
        true
    }
}

enum ButtonMsg {}

struct ButtonModel {}

impl Model for ButtonModel {
    type Msg = ButtonMsg;
    type Widgets = ButtonWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for ButtonModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        ButtonModel {}
    }
    fn update(
        &amp;mut self,
        _msg: ButtonMsg,
        _components: &amp;(),
        _sender: Sender&lt;ButtonMsg&gt;,
        _parent_sender: Sender&lt;AppMsg&gt;,
    ) {
    }
}

#[allow(dead_code)]
struct ButtonWidgets {
    _gtk_button_0: gtk::Button,
}

impl Widgets&lt;ButtonModel, AppModel&gt; for ButtonWidgets {
    type Root = gtk::Button;
    /// Initialize the UI.
    fn init_view(
        model: &amp;ButtonModel,
        parent_widgets: &amp;&lt;AppModel as ::relm4::Model&gt;::Widgets,
        sender: ::gtk::glib::Sender&lt;&lt;ButtonModel as ::relm4::Model&gt;::Msg&gt;,
    ) -&gt; Self {
        let _gtk_button_0 = gtk::Button::default();
        _gtk_button_0.set_label(&quot;ButtonComponent!&quot;);
        Self { _gtk_button_0 }
    }
    fn connect_components(&amp;self, model: &amp;ButtonModel, components: &amp;&lt;ButtonModel as ::relm4::Model&gt;::Components) {}
    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self._gtk_button_0.clone()
    }
    /// Update the view to represent the updated model.
    fn view(
        &amp;mut self,
        model: &amp;ButtonModel,
        sender: ::gtk::glib::Sender&lt;&lt;ButtonModel as ::relm4::Model&gt;::Msg&gt;,
    ) {
    }
}

pub struct AppComponents {
    button1: RelmComponent&lt;ButtonModel, AppModel&gt;,
    button2: RelmComponent&lt;ButtonModel, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            button1: RelmComponent::new(model, parent_widgets, sender.clone()),
            button2: RelmComponent::new(model, parent_widgets, sender),
        }
    }
}

fn new_label() -&gt; gtk::Label {
    gtk::Label::new(Some(&quot;test&quot;))
}

#[allow(dead_code)]
struct AppWidgets {
    main_window: gtk::ApplicationWindow,
    _gtk_box_7: gtk::Box,
    inc_button: gtk::Button,
    _gtk_button_new_1: gtk::Button,
    _new_label_2: gtk::Label,
    _gtk_grid_6: gtk::Grid,
    _gtk_label_3: gtk::Label,
    _gtk_label_4: gtk::Label,
    _gtk_label_5: gtk::Label,
    test_field: u8,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;
    /// Initialize the UI.
    fn init_view(
        model: &amp;AppModel,
        parent_widgets: &amp;(),
        sender: ::gtk::glib::Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        let mut test_field = 0;
        println!(&quot;Pre init! test_field: {}&quot;, test_field);
        let main_window = gtk::ApplicationWindow::default();
        let _gtk_box_7 = gtk::Box::default();
        let inc_button = gtk::Button::default();
        let _gtk_button_new_1 = gtk::Button::new();
        let _new_label_2 = new_label();
        let _gtk_grid_6 = gtk::Grid::default();
        let _gtk_label_3 = gtk::Label::default();
        let _gtk_label_4 = gtk::Label::default();
        let _gtk_label_5 = gtk::Label::default();
        gtk::prelude::GtkWindowExt::set_title(&amp;main_window, Some(&quot;Simple app&quot;));
        main_window.set_default_width(300);
        main_window.set_default_height(100);
        _gtk_box_7.set_orientation(gtk::Orientation::Vertical);
        if let Some(__p_assign) = Some(5) {
            _gtk_box_7.set_margin_all(__p_assign);
        }
        _gtk_box_7.set_spacing(5);
        inc_button.set_label(&quot;Increment&quot;);
        for __elem in &amp;model.classes {
            inc_button.add_css_class(__elem);
        }
        _gtk_button_new_1.set_label(&amp;format!(&quot;Last decrement at {}&quot;, model.counter));
        _new_label_2.set_margin_all(5);
        _new_label_2.set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));
        _gtk_grid_6.set_vexpand(true);
        _gtk_grid_6.set_hexpand(true);
        _gtk_grid_6.set_row_spacing(10);
        _gtk_grid_6.set_column_spacing(10);
        _gtk_grid_6.set_column_homogeneous(true);
        _gtk_label_3.set_label(&quot;grid test 1&quot;);
        _gtk_label_4.set_label(&quot;grid test 2&quot;);
        _gtk_label_5.set_label(&quot;grid test 3&quot;);
        {
            #[allow(clippy::redundant_clone)]
            let sender = sender.clone();
            inc_button.connect_clicked(move |_| {
                send!(sender, AppMsg::Increment);
            });
        }
        {
            #[allow(clippy::redundant_clone)]
            let sender = sender.clone();
            _gtk_button_new_1.connect_clicked(move |_| {
                send!(sender, AppMsg::Decrement);
            });
        }
        relm4::set_global_css(b&quot;.first { color: green; } .second { border: 1px solid orange; }&quot;);
        test_field = 42;
        println!(&quot;Post init! test_field: {}&quot;, test_field);
        Self {
            main_window,
            _gtk_box_7,
            inc_button,
            _gtk_button_new_1,
            _new_label_2,
            _gtk_grid_6,
            _gtk_label_3,
            _gtk_label_4,
            _gtk_label_5,
            test_field,
        }
    }

    fn connect_components(&amp;self, model: &amp;AppModel, components: &amp;&lt;AppModel as ::relm4::Model&gt;::Components) {
        self.main_window.set_child(Some(&amp;self._gtk_box_7));
        self._gtk_box_7.append(components.button1.root_widget());
        self._gtk_box_7.append(&amp;self.inc_button);
        self._gtk_box_7.append(&amp;self._gtk_button_new_1);
        self._gtk_box_7.append(&amp;self._new_label_2);
        self._gtk_box_7.append(&amp;self._gtk_grid_6);
        self._gtk_grid_6.attach(&amp;self._gtk_label_3, 1, 1, 1, 1);
        self._gtk_grid_6.attach(&amp;self._gtk_label_4, 1, 2, 1, 1);
        self._gtk_grid_6.attach(&amp;self._gtk_label_5, 2, 1, 1, 1);
        self._gtk_grid_6
            .attach(components.button2.root_widget(), 2, 2, 1, 1);
    }

    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.main_window.clone()
    }

    /// Update the view to represent the updated model.
    fn view(
        &amp;mut self,
        model: &amp;AppModel,
        sender: ::gtk::glib::Sender&lt;&lt;AppModel as ::relm4::Model&gt;::Msg&gt;,
    ) {
        self.test_field += 1;
        println!(&quot;Manual view! test_field: {}&quot;, self.test_field);

        self._new_label_2
            .set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));

        if model.decrement {
            self._gtk_button_new_1
                .set_label(&amp;format!(&quot;Last decrement at {}&quot;, model.counter));
        }
    }
}

fn main() {
    let model = AppModel {
        counter: 0,
        classes: vec![&quot;first&quot;, &quot;second&quot;],
        decrement: false,
    };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<p>The following chapter contains templates for implementing apps, components and workers that help you develop your apps even faster.</p>
<p>The structs have names like <code>AppModel</code> or <code>ComponentWidgets</code>. You can use search and replace to insert your own names.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-template"><a class="header" href="#app-template">App template</a></h1>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{WidgetExt};
use relm4::*;

struct AppComponents {
    component: RelmComponent&lt;ComponentModel, AppModel&gt;,
}

impl Components&lt;AppModel&gt; for AppComponents {
    fn init_components(
        parent_model: &amp;AppModel,
        parent_widgets: &amp;AppWidgets,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) -&gt; Self {
        AppComponents {
            component: RelmComponent::new(parent_model, parent_widgets, parent_sender.clone()),
        }
    }
}

enum AppMsg {
	
}

struct AppModel {

}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = AppComponents;
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, components: &amp;AppComponents, sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {

        }
        true
    }
}

#[relm4_macros::widget]
impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    view! {
        main_window = gtk::ApplicationWindow {
            
        }
    }
}

fn main() {
    let model = AppModel {
        
    };
    let relm = RelmApp::new(model);
    relm.run();
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-template"><a class="header" href="#component-template">Component template</a></h1>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{WidgetExt};
use relm4::*;

struct ComponentModel {

}

enum ComponentMsg {

}

impl Model for ComponentModel {
    type Msg = ComponentMsg;
    type Widgets = ComponentWidgets;
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for ComponentModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        ComponentModel {

        }
    }

    fn update(
        &amp;mut self,
        msg: ComponentMsg,
        _components: &amp;(),
        sender: Sender&lt;ComponentMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {

        }
    }
}

#[relm4_macros::widget]
impl Widgets&lt;ComponentModel, AppModel&gt; for ComponentWidgets {
    view! {
        
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worker-template"><a class="header" href="#worker-template">Worker template</a></h1>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{WidgetExt};
use relm4::*;

struct WorkerModel {

}

enum WorkerMsg {

}

impl Model for WorkerModel {
    type Msg = WorkerMsg;
    type Widgets = ();
    type Components = ();
}

impl ComponentUpdate&lt;AppModel&gt; for WorkerModel {
    fn init_model(_parent_model: &amp;AppModel) -&gt; Self {
        WorkerModel {

        }
    }

    fn update(
        &amp;mut self,
        msg: WorkerMsg,
        _components: &amp;(),
        sender: Sender&lt;WorkerMsg&gt;,
        parent_sender: Sender&lt;AppMsg&gt;,
    ) {
        match msg {

        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guides"><a class="header" href="#migration-guides">Migration guides</a></h1>
<p>The sections of this chapter will help you to migrate your code from a previous version of Relm4 to the latest version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-from-v02-to-v04"><a class="header" href="#migration-from-v02-to-v04">Migration from v0.2 to v0.4</a></h1>
<p>Fortunately, there aren't many big breaking changes in version 0.4 despite a lot of improvements under the hood.</p>
<blockquote>
<p>In case you're wondering what happened to version 0.3, Relm4 now tries to follow the version number of gtk4-rs and therefore skipped v0.3.</p>
</blockquote>
<h2 id="factoryprototype"><a class="header" href="#factoryprototype">FactoryPrototype</a></h2>
<p>The methods of <a href="https://aaronerhardt.github.io/docs/relm4/relm4/factory/trait.FactoryPrototype.html"><code>FactoryPrototype</code></a> were renamed to better match the rest of Relm4's traits.</p>
<ul>
<li><code>generate</code> =&gt; <code>init_view</code></li>
<li><code>update</code> =&gt; <code>view</code></li>
<li><code>get_root</code> =&gt; <code>root_widget</code></li>
</ul>
<h2 id="widget-macro"><a class="header" href="#widget-macro"><code>widget</code> macro</a></h2>
<ul>
<li><code>manual_view</code> was renamed to <code>post_view</code> and <code>pre_view</code> was added to run code before the macro generated code in the view function.</li>
<li><code>component!</code> was removed, components are now accessible without extra code.</li>
<li><code>parent!</code> was added to access the parent widgets which previously required no extra code.</li>
</ul>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p>The <a href="https://aaronerhardt.github.io/docs/relm4/relm4/trait.Components.html"><code>Components</code></a> trait now has a new method called <code>connect_parent</code>.
This method doesn't do much more than passing the parent widgets down to individual components and originated unintentionally in the rework of the initialization process.
Because this method is usually just repetitive code, you can now use the derive macro instead:</p>
<pre><pre class="playground"><code class="language-rust  no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(relm4::Components)]
struct AppComponents {
    header: RelmComponent&lt;HeaderModel, AppModel&gt;,
    dialog: RelmComponent&lt;DialogModel, AppModel&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The derive macro will always use <code>RelmWorker::with_new_thread()</code> for workers.</p>
<p>Also, <code>RelmComponent::with_new_thread()</code> was removed due to the restructuring. 
It's recommended to use workers or message handlers for blocking operations instead.</p>
<blockquote>
<p>If there's anything missing, let me know. You can simply open an issue on <a href="https://github.com/AaronErhardt/Relm4">GitHub</a> or write a message in the <a href="https://matrix.to/#/#relm4:matrix.org">Matrix room</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
