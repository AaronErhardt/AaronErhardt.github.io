<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Your first app - GUI development with Relm4</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="first_app.html" class="active"><strong aria-hidden="true">1.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="widget_macro.html"><strong aria-hidden="true">2.</strong> The widget macro</a></li><li class="chapter-item expanded "><a href="efficient_ui.html"><strong aria-hidden="true">3.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tracker.html"><strong aria-hidden="true">3.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="factory.html"><strong aria-hidden="true">3.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="factory_position.html"><strong aria-hidden="true">3.3.</strong> The position function</a></li><li class="chapter-item expanded "><a href="factory_advanced.html"><strong aria-hidden="true">3.4.</strong> Advanced factories</a></li></ol></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">4.</strong> Components</a></li><li class="chapter-item expanded "><a href="worker.html"><strong aria-hidden="true">5.</strong> Workers</a></li><li class="chapter-item expanded "><a href="message_handler.html"><strong aria-hidden="true">6.</strong> Message handlers</a></li><li class="chapter-item expanded "><a href="threads_and_async.html"><strong aria-hidden="true">7.</strong> Threads and async</a></li><li class="chapter-item expanded "><a href="reusable_components.html"><strong aria-hidden="true">8.</strong> Reusable components</a></li><li class="chapter-item expanded "><a href="gtk_rs.html"><strong aria-hidden="true">9.</strong> gtk-rs overview</a></li><li class="chapter-item expanded "><a href="widget_macro_reference.html"><strong aria-hidden="true">10.</strong> Widget macro reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widget_macro_expansion.html"><strong aria-hidden="true">10.1.</strong> Macro expansion</a></li></ol></li><li class="chapter-item expanded "><a href="templates.html"><strong aria-hidden="true">11.</strong> Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app_template.html"><strong aria-hidden="true">11.1.</strong> App template</a></li><li class="chapter-item expanded "><a href="component_template.html"><strong aria-hidden="true">11.2.</strong> Component template</a></li><li class="chapter-item expanded "><a href="worker_template.html"><strong aria-hidden="true">11.3.</strong> Worker template</a></li></ol></li><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">12.</strong> Migration guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="0_2_to_0_4.html"><strong aria-hidden="true">12.1.</strong> 0.2 to 0.4</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AaronErhardt/AaronErhardt.github.io/tree/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="your-first-app"><a class="header" href="#your-first-app">Your first app</a></h1>
<p>For our first app, let's create something original: a counter app.</p>
<p><img src="img/screenshots/simple-dark.png" alt="App screenshot dark" /></p>
<p>In this app, we will have a counter which can be incremented and decremented by pressing the corresponding buttons.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/simple_manual.rs">here</a>. Run <code>cargo run --example simple_manual</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="application-architecture"><a class="header" href="#application-architecture">Application architecture</a></h2>
<p>Often, programming concepts are easier to understand when explained with examples or metaphors from the real world. To understand how Relm4 apps work, you can think about a computer as a person.</p>
<p>Our job as a programmer is to ensure that the users of our app will be able to communicate with the computer through the UI. Since the computer can't understand our human language, it needs some help from us to get the communication going. </p>
<p>Let's have a look at what we need to get this done!</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>To help the computer understand what we want to tell it, we first translate user interactions into messages.</p>
<p>In Relm4, a message can be any data type, but most often, an <code>enum</code> is used. In our case, we just want to tell the computer to either increment or decrement a counter.</p>
<pre><code class="language-rust no_run noplayground">enum AppMsg {
    Increment,
    Decrement,
}
</code></pre>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>Like a person, a computer needs a brain to be functional. It needs to process our messages and remember the results.</p>
<p>Relm4 uses the term <code>Model</code> as a data type that represents the application state, the memory of your application. For our counter app, the computer only needs to remember the counter value, so an <code>u8</code> is all we need.</p>
<pre><code class="language-rust no_run noplayground">struct AppModel {
    counter: u8,
}
</code></pre>
<h3 id="the-appupdate-trait"><a class="header" href="#the-appupdate-trait">The <code>AppUpdate</code> trait</a></h3>
<p>Of course, the brain needs to do more than just remembering things, it also needs to process information.</p>
<p>Here, both the model and message types come into play. The <code>update</code> function of the <code>AppUpdate</code> trait tells the computer how to process messages and how to update its memory.</p>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}
</code></pre>
<blockquote>
<p><code>wrapping_add(1)</code> and <code>wrapping_sub(1)</code> are like <code>+1</code>  and <code>-1</code>, but don't panic on overflows.</p>
</blockquote>
<p>Also, we return <code>true</code> to tell the computer to keep our application alive. If our app should close, we can simply return <code>false</code>.</p>
<h3 id="the-widgets"><a class="header" href="#the-widgets">The widgets</a></h3>
<p>The computer is now able to process and remember information, but we still need an interface to communicate with the user.</p>
<p>GTK4 offers the computer widgets that allow it to take input and to respond. Widgets are simply parts of an UI like buttons, input fields or text areas. To be able to update the widgets in our program, we can put them all into a <code>struct</code>.</p>
<p>For our app, we use a window with two buttons to increment and decrement the counter and a label to display the counter value. Besides that, we need a box as a container to place our buttons and the label inside because a window can only have one child.</p>
<pre><code class="language-rust no_run noplayground">struct AppWidgets {
    window: gtk::ApplicationWindow,
    vbox: gtk::Box,
    inc_button: gtk::Button,
    dec_button: gtk::Button,
    label: gtk::Label,
}
</code></pre>
<h3 id="the-widgets-trait"><a class="header" href="#the-widgets-trait">The <code>Widgets</code> trait</a></h3>
<p>The last step is to tell the computer how to initialize widgets and how to update them.</p>
<p>In Relm4, the UI represents the memory of the application. All that's left to do is to implement the <code>Widgets</code> trait that tells the computer exactly how its memory should be visualized.</p>
<p>Let's do this step by step. First, we'll have a look at the beginning of the trait <code>impl</code>.</p>
<pre><code class="language-rust no_run noplayground">impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;
</code></pre>
<p>The two generic parameters are our model and the parent model. We're at the root of our app so we don't have a parent model and can use <code>()</code> as placeholder.</p>
<p>The <code>Root</code> type is the outermost widget of the app. Components can choose this type freely, but the main application must use an <code>ApplicationWindow</code>.</p>
<p>Next up, we want to initialize our UI.</p>
<blockquote>
<p>Don't worry about the amount of manual code you need for handling widgets. In the next chapter, we'll see how this can be done easier.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">    /// Initialize the UI.
    fn init_view(model: &amp;AppModel, _parent_widgets: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let window = gtk::ApplicationWindow::builder()
            .title(&quot;Simple app&quot;)
            .default_width(300)
            .default_height(100)
            .build();
        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();
        vbox.set_margin_all(5);

        let inc_button = gtk::Button::with_label(&quot;Increment&quot;);
        let dec_button = gtk::Button::with_label(&quot;Decrement&quot;);

        let label = gtk::Label::new(Some(&amp;format!(&quot;Counter: {}&quot;, model.counter)));
        label.set_margin_all(5);

        // Connect the widgets
        window.set_child(Some(&amp;vbox));
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        // Connect events
        let btn_sender = sender.clone();
        inc_button.connect_clicked(move |_| {
            send!(btn_sender, AppMsg::Increment);
        });

        dec_button.connect_clicked(move |_| {
            send!(sender, AppMsg::Decrement);
        });

        Self {
            window,
            vbox,
            inc_button,
            dec_button,
            label,
        }
    }
</code></pre>
<p>First, we initialize each of our widgets, mostly by using builder patterns.</p>
<p>Then we connect the widgets so that GTK4 knows how they are related to each other. The buttons and the label are added as children of the box, and the box is added as the child of the window.</p>
<p>Next, we connect the &quot;clicked&quot; event for both buttons and send a message from the closures to the computer. To do this, we only need to move a cloned sender into the closures and send the message. Now every time we click our buttons, a message will be sent to update our counter!</p>
<p>Still our UI will not update when the counter is changed. To do this, we need to implement the view function that modifies the UI according to the changes in the model.</p>
<pre><code class="language-rust no_run noplayground">    /// Update the view to represent the updated model.
    fn view(&amp;mut self, model: &amp;AppModel, _sender: Sender&lt;AppMsg&gt;) {
        self.label.set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));
    }
</code></pre>
<p>We're almost done. To complete the <code>Widgets</code> trait, we just need to implement the <code>root_widget</code> method that simply returns the <code>Root</code>.</p>
<pre><code class="language-rust no_run noplayground">    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.window.clone()
    }
</code></pre>
<h3 id="the-model-trait"><a class="header" href="#the-model-trait">The <code>Model</code> trait</a></h3>
<p>In the <code>Model</code> trait, everything comes together. This trait just describes how the types we defined work together.</p>
<pre><code class="language-rust no_run noplayground">impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}
</code></pre>
<h2 id="running-the-app"><a class="header" href="#running-the-app">Running the App</a></h2>
<p>The last step is to run the app we just wrote. To do so, we just need to initialize our model and pass it into <code>RelmApp::new()</code>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let model = AppModel { counter: 0 };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>
<p>🎉 Congratulations! You just wrote your first app with Relm4! 🎉</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Let's summarize what we learned in this chapter.</p>
<p>A Relm4 application has three important types:</p>
<ol>
<li>The model type that stores the application state, the memory of our app.</li>
<li>The message type that describes which information can be sent to update the model.</li>
<li>The widgets type that stores our widgets.</li>
</ol>
<p>Also, there are two important functions:</p>
<ol>
<li><code>update</code> receives a message and updates the model accordingly.</li>
<li><code>view</code> receives the updated model and updates the widgets accordingly.</li>
</ol>
<p>The app does all those things in a loop. It waits for messages and once a message is received, it runs <code>update</code> and then <code>view</code>.</p>
<p><img src="img/update_loop.svg" alt="relm update loop" /></p>
<blockquote>
<p>Relm4 separates the data and the UI. The UI never knows which message was sent, but can only read the model. This might seem like a limitation, but it helps you to create maintainable, stable and consistent applications.</p>
</blockquote>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>I hope this chapter made everything clear for you :)</p>
<p>If you found a mistake or there was something unclear, please open an issue <a href="https://github.com/AaronErhardt/relm4/issues">here</a>.</p>
<p>As you have seen, initializing the UI was by far the largest part of our app, with roughly one half of the total code. In the next chapter, we will have a look at the <code>relm4-macros</code> crate that offers a macro that helps us to reduce the amount of code we need to implement the Widgets trait.</p>
<blockquote>
<p>As you might have noticed, storing <code>inc_button</code>, <code>dec_button</code> and <code>vbox</code> in our widgets <code>struct</code> is not necessary because GTK will keep them alive automatically. Therefore, we can remove them from <code>AppWidgets</code> to avoid compiler warnings.</p>
</blockquote>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece to see how all these parts work together:</p>
<pre><code class="language-rust no_run noplayground">use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt};
use relm4::{send, AppUpdate, Model, RelmApp, Sender, WidgetPlus, Widgets};

struct AppModel {
    counter: u8,
}

enum AppMsg {
    Increment,
    Decrement,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::Increment =&gt; {
                self.counter = self.counter.wrapping_add(1);
            }
            AppMsg::Decrement =&gt; {
                self.counter = self.counter.wrapping_sub(1);
            }
        }
        true
    }
}

struct AppWidgets {
    window: gtk::ApplicationWindow,
    vbox: gtk::Box,
    inc_button: gtk::Button,
    dec_button: gtk::Button,
    label: gtk::Label,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;

    /// Initialize the UI.
    fn init_view(model: &amp;AppModel, _parent_widgets: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let window = gtk::ApplicationWindow::builder()
            .title(&quot;Simple app&quot;)
            .default_width(300)
            .default_height(100)
            .build();
        let vbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .spacing(5)
            .build();
        vbox.set_margin_all(5);

        let inc_button = gtk::Button::with_label(&quot;Increment&quot;);
        let dec_button = gtk::Button::with_label(&quot;Decrement&quot;);

        let label = gtk::Label::new(Some(&amp;format!(&quot;Counter: {}&quot;, model.counter)));
        label.set_margin_all(5);

        // Connect the widgets
        window.set_child(Some(&amp;vbox));
        vbox.append(&amp;inc_button);
        vbox.append(&amp;dec_button);
        vbox.append(&amp;label);

        // Connect events
        let btn_sender = sender.clone();
        inc_button.connect_clicked(move |_| {
            send!(btn_sender, AppMsg::Increment);
        });

        dec_button.connect_clicked(move |_| {
            send!(sender, AppMsg::Decrement);
        });

        Self {
            window,
            vbox,
            inc_button,
            dec_button,
            label,
        }
    }

    /// Return the root widget.
    fn root_widget(&amp;self) -&gt; Self::Root {
        self.window.clone()
    }

    /// Update the view to represent the updated model.
    fn view(&amp;mut self, model: &amp;AppModel, _sender: Sender&lt;AppMsg&gt;) {
        self.label.set_label(&amp;format!(&quot;Counter: {}&quot;, model.counter));
    }
}

fn main() {
    let model = AppModel { counter: 0 };
    let app = RelmApp::new(model);
    app.run();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="widget_macro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="widget_macro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
