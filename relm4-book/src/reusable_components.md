# Reusable components

In this chapter, we will implement a simple alert dialog as a reusable component.

> You can find more examples of reusable components in the relm4-components crate [here](https://github.com/AaronErhardt/relm4/tree/main/relm4-components). You can also contribute your own reusable components to relm4-components :)

Reusable components don’t know their parent component at the time they are implemented. So if they want to interact with their parent component, they must assume that their parent model defines a trait that defines how to interact with the components.

## The parent traits

First, we’ll have a look at the traits the parent component, that will eventually use this component, has to implement.

Because we want our component to be flexible and able to display different messages, we first define a data type for configuring our component.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:settings }}

```

Next, we define a trait for our parent model that defines the messages our component will send to respond to the parent. The trait also defines a function that passes a new configuration to our component.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:parent_trait }}

```

Because you usually want to tell GTK to which window a dialog belongs to, we also add a trait that allows us to pass the parent window.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:parent_widgets_trait }}

```

## The model

Our model stores whether the component is visible and the configuration.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:model }}

```

The message type only exposes the `Show` message to the parent component. The `Response` message is used internally for handling user interactions, so we hide it with `#[doc(hidden)]`.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:msg }}

```

The `ComponentUpdate` trait would usually expect the parent component as a generic parameter. We don’t know the parent component yet, so we add trait bounds to a new generic type.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:component_update_start }}

```

For initializing our model, we get the configuration from our parent component and set `is_active` to `false`.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:init_model }}

```

The update function handles the `Show` message from our parent component and the `Response` messages generated by user interactions. It also sends the appropriate messages to the parent.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:component_update }}

```

## The widgets

The widgets have also a generic type for the parent component with the expected trait bounds. Apart from that, there is nothing special.

```rust,no_run,noplayground

{{#include ../listings/alert.rs:widgets }}

```

## Conclusion

We’re done! That’s your first reusable component. If you want to see the alert component, we just wrote, used inside a Relm4 application have a look at the [“alert” example](https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/alert.rs).

> If you need a component for your application that you expect to be useful to others, too, we’d be happy if you’d consider contributing to relm4-components, a crate that offers reusable components.

## The complete code

Let’s review our code in one piece one more time to see how all these parts work together:

```rust,no_run,noplayground

{{#include ../listings/alert.rs:all }}

```