<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced factories - GUI development with Relm4</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="first_app.html"><strong aria-hidden="true">1.</strong> Your first app</a></li><li class="chapter-item expanded "><a href="widget_macro.html"><strong aria-hidden="true">2.</strong> The widget macro</a></li><li class="chapter-item expanded "><a href="efficient_ui.html"><strong aria-hidden="true">3.</strong> Efficient UI updates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tracker.html"><strong aria-hidden="true">3.1.</strong> Tracker</a></li><li class="chapter-item expanded "><a href="factory.html"><strong aria-hidden="true">3.2.</strong> Factories</a></li><li class="chapter-item expanded "><a href="factory_advanced.html" class="active"><strong aria-hidden="true">3.3.</strong> Advanced factories</a></li></ol></li><li class="chapter-item expanded "><a href="components.html"><strong aria-hidden="true">4.</strong> Components</a></li><li class="chapter-item expanded "><a href="worker.html"><strong aria-hidden="true">5.</strong> Workers</a></li><li class="chapter-item expanded "><a href="threads_and_async.html"><strong aria-hidden="true">6.</strong> Threads and async</a></li><li class="chapter-item expanded "><a href="reusable_components.html"><strong aria-hidden="true">7.</strong> Reusable components</a></li><li class="chapter-item expanded "><a href="widget_macro_reference.html"><strong aria-hidden="true">8.</strong> Widget macro reference</a></li><li class="chapter-item expanded "><a href="templates.html"><strong aria-hidden="true">9.</strong> Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app_template.html"><strong aria-hidden="true">9.1.</strong> App template</a></li><li class="chapter-item expanded "><a href="component_template.html"><strong aria-hidden="true">9.2.</strong> Component template</a></li><li class="chapter-item expanded "><a href="worker_template.html"><strong aria-hidden="true">9.3.</strong> Worker template</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Relm4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/AaronErhardt/AaronErhardt.github.io/tree/master/relm4-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advanced-factories"><a class="header" href="#advanced-factories">Advanced factories</a></h1>
<blockquote>
<p>If you're not familiar with the <code>Rc</code> type of the standard library, have a look at <a href="https://doc.rust-lang.org/std/rc/index.html">this</a>.</p>
</blockquote>
<p>The <code>FactoryVec</code> we used in the previous chapter is sufficient for simple applications where elements only need to be added and removed from the back. Yet a common use case would be to add elements before another one or to remove a specific element. That introduces additional complexity that needs to be taken care of but fortunately this is mostly handled by Relm4.</p>
<p>To show this, we'll create a similar counter app to the one of the previous chapter, but this time on <strong>steroids</strong>: we'll add functionality to add counters before and after a specific counter and to remove a certain counter. To get the required flexibility, we'll use the <code>FactoryVecDeque</code> type instead of a <code>FactoryVec</code>.</p>
<blockquote>
<p>The app we will write in this chapter is also available <a href="https://github.com/AaronErhardt/relm4/blob/main/relm4-examples/examples/factory_advanced.rs">here</a>. Run <code>cargo run --example factory_advanced</code> from the <a href="https://github.com/AaronErhardt/relm4/tree/main/relm4-examples">example directory</a> if you want to see the code in action.</p>
</blockquote>
<h2 id="indices"><a class="header" href="#indices">Indices</a></h2>
<p>The indices of a <code>FactoryVec</code> were just numbers of type <code>usize</code>. That's great unless elements can move and change their index. This tragedy starts when we, for example, add an element to the front: the new element now has index <code>0</code>, the element that had index <code>0</code> before now has index <code>1</code> and so on. Adding one element will shift the indices of all following elements. If we naively create a signal handler similar to the previous chapter were we just copied the index at start and moved it into the closure, we will quickly end up with quite wrong or even out-of-bounds indices as elements are added and removed at arbitrary positions.</p>
<p>One solution would be to recreate all signal handlers with the updated indices once an element's index has been changed. However, that's complicated because you need to remove the old signal handlers first and therefore you have to store all signal handler IDs.</p>
<p>The solution Relm4 chose was dynamic indices. These indices are updated automatically to always point at the same element.</p>
<h3 id="the-message-type"><a class="header" href="#the-message-type">The message type</a></h3>
<pre><code class="language-rust no_run noplayground">enum AppMsg {
    AddFirst,
    RemoveLast,
    CountAt(Rc&lt;DynamicIndex&gt;),
    RemoveAt(Rc&lt;DynamicIndex&gt;),
    InsertBefore(Rc&lt;DynamicIndex&gt;),
    InsertAfter(Rc&lt;DynamicIndex&gt;),
}
</code></pre>
<p>As you can see, we use a lot of <code>Rc&lt;DynamicIndex&gt;</code>. This allows us to always hold a reference to the dynamic index value.</p>
<blockquote>
<p>You might consider using <code>Weak</code> instead of <code>Rc</code> for messages because <code>Rc</code> will keep alive indices of removed elements inside queued messages (which rarely happens). For simplicity, we will use <code>Rc</code> here.</p>
</blockquote>
<h3 id="the-model"><a class="header" href="#the-model">The model</a></h3>
<p>The model is very similar to the previous chapter. The only difference is that we use <code>FactoryVecDeque</code> as a data structure now.</p>
<pre><code class="language-rust no_run noplayground">struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVecDeque&lt;Counter&gt;,
    received_messages: u8,
}
</code></pre>
<h3 id="the-update-function"><a class="header" href="#the-update-function">The update function</a></h3>
<p>The update function now handles quite a lot of events. We want to</p>
<ul>
<li>Add elements at the start</li>
<li>Remove elements from the back</li>
<li>Decrement (count) a counter at a specific index</li>
<li>Insert a new counter before another counter</li>
<li>Insert a new counter after another counter</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::AddFirst =&gt; {
                self.counters.push_front(Counter {
                    value: self.received_messages,
                });
            }
            AppMsg::RemoveLast =&gt; {
                self.counters.pop_back();
            }
            AppMsg::CountAt(index) =&gt; {
                if let Some(counter) = self.counters.get_mut(index.current_index()) {
                    counter.value = counter.value.wrapping_sub(1);
                }
            }
            AppMsg::RemoveAt(index) =&gt; {
                self.counters.remove(index.current_index());
            }
            AppMsg::InsertBefore(index) =&gt; {
                self.counters.insert(
                    index.current_index(),
                    Counter {
                        value: self.received_messages,
                    },
                );
            }
            AppMsg::InsertAfter(index) =&gt; {
                self.counters.insert(
                    index.current_index() + 1,
                    Counter {
                        value: self.received_messages,
                    },
                );
            }
        }
        self.received_messages += 1;
        true
    }
}
</code></pre>
<p>To get the current index value from the dynamic index, we simply call <code>index.current_index()</code>.</p>
<h2 id="the-factory-implementation"><a class="header" href="#the-factory-implementation">The factory implementation</a></h2>
<p>The factory implementation is mostly the same, so we'll just have a look at what has changed.</p>
<h3 id="the-widgets-type"><a class="header" href="#the-widgets-type">The widgets type</a></h3>
<p>Because we have four actions per counter now, we also need an additional box to store these buttons.</p>
<pre><code class="language-rust no_run noplayground">struct FactoryWidgets {
    hbox: gtk::Box,
    counter_button: gtk::Button,
}
</code></pre>
<h3 id="the-generate-function"><a class="header" href="#the-generate-function">The generate function</a></h3>
<p>For the generate function, we need to first generate the new buttons and the box.</p>
<pre><code class="language-rust no_run noplayground">    fn generate(&amp;self, index: &amp;Rc&lt;DynamicIndex&gt;, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let hbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Horizontal)
            .spacing(5)
            .build();

        let counter_button = gtk::Button::with_label(&amp;self.value.to_string());
        let index: Rc&lt;DynamicIndex&gt; = index.clone();

        let remove_button = gtk::Button::with_label(&quot;Remove&quot;);
        let ins_above_button = gtk::Button::with_label(&quot;Add above&quot;);
        let ins_below_button = gtk::Button::with_label(&quot;Add below&quot;);
</code></pre>
<p>Then we need to place the buttons inside of the box.</p>
<pre><code class="language-rust no_run noplayground">        hbox.append(&amp;counter_button);
        hbox.append(&amp;remove_button);
        hbox.append(&amp;ins_above_button);
        hbox.append(&amp;ins_below_button);
</code></pre>
<p>Now we can connect the messages. Note that we always send a cloned <code>Rc</code> of our dynamic index.</p>
<pre><code class="language-rust no_run noplayground">        {
            let sender = sender.clone();
            let index = index.clone();
            counter_button.connect_clicked(move |_| {
                send!(sender, AppMsg::CountAt(index.clone()));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            remove_button.connect_clicked(move |_| {
                send!(sender, AppMsg::RemoveAt(index.clone()));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            ins_above_button.connect_clicked(move |_| {
                send!(sender, AppMsg::InsertBefore(index.clone()));
            });
        }

        ins_below_button.connect_clicked(move |_| {
            send!(sender, AppMsg::InsertAfter(index.clone()));
        });
</code></pre>
<p>And that's it! All the other complex operations that keep track of changes are implemented in Relm4 already, we just need to use dynamic indices to make out program work :)</p>
<h2 id="the-complete-code"><a class="header" href="#the-complete-code">The complete code</a></h2>
<p>Let's review our code in one piece one more time to see how all these parts work together:</p>
<blockquote>
<p>Unlike the example in the previous chapter, the following code does not use the widget macro from relm4-macros but implements the <code>Widgets</code> trait manually. Yet, the generated code from the macro and the manual code should be almost identical.</p>
</blockquote>
<pre><code class="language-rust no_run noplayground">use gtk::glib::Sender;
use gtk::prelude::{BoxExt, ButtonExt, GtkWindowExt};
use relm4::factory::{DynamicIndex, Factory, FactoryPrototype, FactoryVecDeque};
use relm4::*;

use std::rc::Rc;

#[derive(Debug)]
enum AppMsg {
    AddFirst,
    RemoveLast,
    CountAt(Rc&lt;DynamicIndex&gt;),
    RemoveAt(Rc&lt;DynamicIndex&gt;),
    InsertBefore(Rc&lt;DynamicIndex&gt;),
    InsertAfter(Rc&lt;DynamicIndex&gt;),
}

struct Counter {
    value: u8,
}

struct AppModel {
    counters: FactoryVecDeque&lt;Counter&gt;,
    received_messages: u8,
}

impl Model for AppModel {
    type Msg = AppMsg;
    type Widgets = AppWidgets;
    type Components = ();
}

impl AppUpdate for AppModel {
    fn update(&amp;mut self, msg: AppMsg, _components: &amp;(), _sender: Sender&lt;AppMsg&gt;) -&gt; bool {
        match msg {
            AppMsg::AddFirst =&gt; {
                self.counters.push_front(Counter {
                    value: self.received_messages,
                });
            }
            AppMsg::RemoveLast =&gt; {
                self.counters.pop_back();
            }
            AppMsg::CountAt(index) =&gt; {
                if let Some(counter) = self.counters.get_mut(index.current_index()) {
                    counter.value = counter.value.wrapping_sub(1);
                }
            }
            AppMsg::RemoveAt(index) =&gt; {
                self.counters.remove(index.current_index());
            }
            AppMsg::InsertBefore(index) =&gt; {
                self.counters.insert(
                    index.current_index(),
                    Counter {
                        value: self.received_messages,
                    },
                );
            }
            AppMsg::InsertAfter(index) =&gt; {
                self.counters.insert(
                    index.current_index() + 1,
                    Counter {
                        value: self.received_messages,
                    },
                );
            }
        }
        self.received_messages += 1;
        true
    }
}

struct FactoryWidgets {
    hbox: gtk::Box,
    counter_button: gtk::Button,
}

impl FactoryPrototype for Counter {
    type Factory = FactoryVecDeque&lt;Self&gt;;
    type Widgets = FactoryWidgets;
    type Root = gtk::Box;
    type View = gtk::Box;
    type Msg = AppMsg;

    fn generate(&amp;self, index: &amp;Rc&lt;DynamicIndex&gt;, sender: Sender&lt;AppMsg&gt;) -&gt; FactoryWidgets {
        let hbox = gtk::Box::builder()
            .orientation(gtk::Orientation::Horizontal)
            .spacing(5)
            .build();

        let counter_button = gtk::Button::with_label(&amp;self.value.to_string());
        let index: Rc&lt;DynamicIndex&gt; = index.clone();

        let remove_button = gtk::Button::with_label(&quot;Remove&quot;);
        let ins_above_button = gtk::Button::with_label(&quot;Add above&quot;);
        let ins_below_button = gtk::Button::with_label(&quot;Add below&quot;);

        hbox.append(&amp;counter_button);
        hbox.append(&amp;remove_button);
        hbox.append(&amp;ins_above_button);
        hbox.append(&amp;ins_below_button);

        {
            let sender = sender.clone();
            let index = index.clone();
            counter_button.connect_clicked(move |_| {
                send!(sender, AppMsg::CountAt(index.clone()));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            remove_button.connect_clicked(move |_| {
                send!(sender, AppMsg::RemoveAt(index.clone()));
            });
        }

        {
            let sender = sender.clone();
            let index = index.clone();
            ins_above_button.connect_clicked(move |_| {
                send!(sender, AppMsg::InsertBefore(index.clone()));
            });
        }

        ins_below_button.connect_clicked(move |_| {
            send!(sender, AppMsg::InsertAfter(index.clone()));
        });

        FactoryWidgets {
            hbox,
            counter_button,
        }
    }

    fn position(&amp;self, _index: &amp;Rc&lt;DynamicIndex&gt;) {}

    fn update(&amp;self, _index: &amp;Rc&lt;DynamicIndex&gt;, widgets: &amp;FactoryWidgets) {
        widgets.counter_button.set_label(&amp;self.value.to_string());
    }
    
    fn get_root(widget: &amp;FactoryWidgets) -&gt; &amp;gtk::Box {
        &amp;widget.hbox
    }
}

struct AppWidgets {
    main: gtk::ApplicationWindow,
    gen_box: gtk::Box,
}

impl Widgets&lt;AppModel, ()&gt; for AppWidgets {
    type Root = gtk::ApplicationWindow;

    fn init_view(_model: &amp;AppModel, _components: &amp;(), sender: Sender&lt;AppMsg&gt;) -&gt; Self {
        let main = gtk::ApplicationWindowBuilder::new()
            .default_width(300)
            .default_height(200)
            .build();
        let main_box = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .margin_end(5)
            .margin_top(5)
            .margin_start(5)
            .margin_bottom(5)
            .spacing(5)
            .build();

        let gen_box = gtk::Box::builder()
            .orientation(gtk::Orientation::Vertical)
            .margin_end(5)
            .margin_top(5)
            .margin_start(5)
            .margin_bottom(5)
            .spacing(5)
            .build();

        let add = gtk::Button::with_label(&quot;Add&quot;);
        let remove = gtk::Button::with_label(&quot;Remove&quot;);

        main_box.append(&amp;add);
        main_box.append(&amp;remove);
        main_box.append(&amp;gen_box);

        main.set_child(Some(&amp;main_box));

        let cloned_sender = sender.clone();
        add.connect_clicked(move |_| {
            cloned_sender.send(AppMsg::AddFirst).unwrap();
        });

        remove.connect_clicked(move |_| {
            sender.send(AppMsg::RemoveLast).unwrap();
        });

        AppWidgets { main, gen_box }
    }

    fn view(&amp;mut self, model: &amp;AppModel, sender: Sender&lt;AppMsg&gt;) {
        model.counters.generate(&amp;self.gen_box, sender);
    }

    fn root_widget(&amp;self) -&gt; gtk::ApplicationWindow {
        self.main.clone()
    }
}

fn main() {
    let model = AppModel {
        counters: FactoryVecDeque::new(),
        received_messages: 0,
    };

    let relm = RelmApp::new(model);
    relm.run();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="factory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="components.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="factory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="components.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
